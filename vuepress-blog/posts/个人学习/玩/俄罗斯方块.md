---
title: c++俄罗斯方块
date: 2024-03-19
category:
  - c++
---

### 02-项目创建

创建空的c++项目。创建两个类，定义好方法，生成代码：

Block.h

```c++
#pragma once
class Block {
public:
	// 构造函数
	Block();

	// 下降
	void drop();

	// 左右移动
	void moveLeftRight(int offset);

	// 旋转
	void retate();

	// 绘制 左边界、上边界
	void draw(int leftMargin,int topMargin);


};
```

Block.cpp

```c++
#include "Block.h"

Block::Block() {
}

void Block::drop() {
}

void Block::moveLeftRight(int offset) {
}

void Block::retate() {
}

void Block::draw(int leftMargin, int topMargin) {
}

```

Tetris.h

```c++
#pragma once
class Tetris {
public:
	//  构造函数 行数、列数、从哪里开始降落（距离左侧和顶部）、方块大小
	Tetris(int rows,int clos,int left,int top,int blockSize);

	// 初始化
	void init();

	// 开始游戏
	void play();
};


```

Tetris.cpp

```c++
#include "Tetris.h"

Tetris::Tetris(int rows, int clos, int left, int top, int blockSize) {
}

void Tetris::init() {
}

void Tetris::play() {
}

```

main.cpp

```c++
#include "Tetris.h"

int main() {
	// 在栈上创建一个名为game的Tetris对象，并调用构造函数初始化对象的状态。栈内存不需要手动释放
	// 参数需要根据背景图计算
	Tetris game(20,10,163,133,36);
	game.play();
	return 0;
}
```

编译运行：如果报错，关闭杀毒软件

![image-20240319221354896](http://www.iocaop.com/images/2024-03/202403192214969.png)

### 03-游戏主循环

写个死循环，到指定时间就刷新画面，定义私有变量记录时间，哨兵标记是否刷新（方便用户按键时不需要等待，直接刷新），声明延时、刷新画面、清行等方法：

```c++
#pragma once
class Tetris {
public:
	//  构造函数 行数、列数、从哪里开始降落（距离左侧和顶部）、方块大小
	Tetris(int rows,int clos,int left,int top,int blockSize);

	// 初始化
	void init();

	// 开始游戏
	void play();

private:
	// 接收用户输入
	void keyEvent();

	// 渲染游戏界面
	void updateWindows();

	// 返回距离上一次渲染的时间,第一次调用时返回0
	int getDelay();

	// 方块降落
	void drop();
	
	// 计算，清行
	void clearLine();


private:
	// 延迟参数，多久渲染一次画面
	int delay;

	// 控制是否渲染
	bool update;
};


```

```c++
#pragma once
class Tetris {
public:
	//  构造函数 行数、列数、从哪里开始降落（距离左侧和顶部）、方块大小
	Tetris(int rows,int clos,int left,int top,int blockSize);

	// 初始化
	void init();

	// 开始游戏
	void play();

private:
	// 接收用户输入
	void keyEvent();

	// 渲染游戏界面
	void updateWindows();

	// 返回距离上一次渲染的时间,第一次调用时返回0
	int getDelay();

	// 方块降落
	void drop();
	
	// 计算，清行
	void clearLine();


private:
	// 延迟参数，多久渲染一次画面
	int delay;

	// 控制是否渲染
	bool update;
};


```

### 04-创建方块

参考：<a href='https://blog.csdn.net/pzjdoytt/article/details/125325753?spm=1001.2014.3001.5501'>点击跳转</a>

一共有7中方块，每个大方块中有4个小方块，定义二位数组，表示这7种方块，二维数组用于记录小方块的值：

```c++
	// 定义7中方块类型
	int blocks[7][4] = {
		1,3,5,7, // I
		2,4,5,7, // Z 1型
		3,5,4,6, // Z 2型
		3,5,4,7, // T
		2,3,5,7, // L
		3,5,7,6, // J
		2,3,4,5, // 田
	};
```

在方块类中定义结构体，记录小方块：

```c++
	// 定义结构体，用于表示大方块中每个小方块具体在第几行第几列
	struct Point {
		int row;
		int col;
	};
```

```c++
private:
	// 方块类型
	int blockType;

	// 小方块
	Point smallBlocks[4];
```

随机生成一种方块：取随机数

```c++
#include <stdlib.h>
	// 随机生成一种
	this->blockType = rand() % 7 + 1;
```

在游戏初始化方法中置随机数种子：

```c++
#include <stdlib.h>
#include <time.h>


void Tetris::init() {
	this->delay = 30;
	// 置随机数种子
	srand(time(NULL));
}
```

随机生成后，计算大方块中，每个小方块的具体位置：

```c++
	// 计算小方块的具体位置,每个大方块有4个小方块
	for (size_t i = 0; i < 4; i++) {
		int value = blocks[blockType][i];
		// 经过观察，方块的具体位置row为值除以2，col为值对2取余
		 this->smallBlocks[i].row = value / 2;
		 this->smallBlocks[i].col = value % 2;
	}
```

完整代码：

Block.h:

```c++
#pragma once
class Block {

	// 定义结构体，用于表示大方块中每个小方块具体在第几行第几列
	struct Point {
		int row;
		int col;
	};
public:
	// 构造函数
	Block();

	// 下降
	void drop();

	// 左右移动
	void moveLeftRight(int offset);

	// 旋转
	void retate();

	// 绘制 左边界、上边界
	void draw(int leftMargin,int topMargin);

private:
	// 方块类型
	int blockType;

	// 小方块
	Point smallBlocks[4];

};


```

Block.cpp:

```c++
#include "Block.h"
#include <stdlib.h>

Block::Block() {
	// 定义7中方块类型
	int blocks[7][4] = {
		1,3,5,7, // I
		2,4,5,7, // Z 1型
		3,5,4,6, // Z 2型
		3,5,4,7, // T
		2,3,5,7, // L
		3,5,7,6, // J
		2,3,4,5, // 田
	};

	// 随机生成一种
	this->blockType = rand() % 7 + 1;

	// 计算小方块的具体位置,每个大方块有4个小方块
	for (size_t i = 0; i < 4; i++) {
		int value = blocks[blockType][i];
		// 经过观察，方块的具体位置row为值除以2，col为值对2取余
		 this->smallBlocks[i].row = value / 2;
		 this->smallBlocks[i].col = value % 2;
	}

}

void Block::drop() {
}

void Block::moveLeftRight(int offset) {
}

void Block::retate() {
}

void Block::draw(int leftMargin, int topMargin) {
}

```

Tetris.cpp:

```c++
#pragma once
class Tetris {
public:
	//  构造函数 行数、列数、从哪里开始降落（距离左侧和顶部）、方块大小
	Tetris(int rows,int clos,int left,int top,int blockSize);

	// 初始化
	void init();

	// 开始游戏
	void play();

private:
	// 接收用户输入
	void keyEvent();

	// 渲染游戏界面
	void updateWindows();

	// 返回距离上一次渲染的时间,第一次调用时返回0
	int getDelay();

	// 方块降落
	void drop();
	
	// 计算，清行
	void clearLine();


private:
	// 延迟参数，多久渲染一次画面
	int delay;

	// 控制是否渲染
	bool update;
};


```

### 05-创建方块的图像纹理

绘制图形，需要先安装easyx图形库。<a href='https://easyx.cn/'>点击跳转</a>

在Block.h中引入：

```c++
#include <graphics.h>
```



在Block类中添加图片指针变量用于指向具体的图片对象，定义静态图片指针数组存储固定不变的7中小方块。

```c++
private:
	// 方块类型
	int blockType;

	// 小方块
	Point smallBlocks[4];

	// 图片变量，因为游戏中的方块图片都是一样的，所以使用指针即可
	IMAGE *img;

	// 一共有7种大方块，我们用不同的颜色表示，所以定义一个静态图片指针数组用来存储,定义静态变量用于存储方块大小
	static IMAGE* images[7] ;
	static int size;
```

在Block类中初始化：

```c++
// 在类外部对静态数组images进行了定义和初始化
IMAGE* Block::images[7] = { NULL };
// 初始化方块大小
int Block::size = 36;
```

构造函数中添加判断，如果第一次为NULL，则加载图片进行切割:

```c++
	// 第一次判断图片是否加载到静态数组，未加载则加载
	if (images[0] = NULL) {
		// 临时变量用于加载图片，进行切割
		IMAGE imgTmp;
		loadimage(&imgTmp,"res/tiles.png");
		// 切割
		SetWorkingImage(&imgTmp);
		for (size_t i = 0; i < 7; i++) {
			images[i] = new IMAGE();
			// 图片对象，切割的x，y，宽度，高度
			getimage(images[i], i*size,0,size,size);
		}
		// 恢复工作区
		SetWorkingImage(&imgTmp);

	}

```

上面已经切割好图片，并创建了图片对象，将对象地址记录在数组中了，所以在生成方块时，直接将方块对象中的图片指针指向图片数组对应的图片即可：

```c++
		 this->img = images[blockType];
```

完整代码：

Block.h:

```c++
#pragma once
#include <graphics.h>
class Block {

	// 定义结构体，用于表示大方块中每个小方块具体在第几行第几列
	struct Point {
		int row;
		int col;
	};
public:
	// 构造函数
	Block();

	// 下降
	void drop();

	// 左右移动
	void moveLeftRight(int offset);

	// 旋转
	void retate();

	// 绘制 左边界、上边界
	void draw(int leftMargin,int topMargin);

private:
	// 方块类型
	int blockType;

	// 小方块
	Point smallBlocks[4];

	// 图片变量，因为游戏中的方块图片都是一样的，所以使用指针即可
	IMAGE *img;

	// 一共有7种大方块，我们用不同的颜色表示，所以定义一个静态图片指针数组用来存储,定义静态变量用于存储方块大小
	static IMAGE* images[7] ;
	static int size;



};


```

Block.cpp:

```c++
#include "Block.h"
#include <stdlib.h>

// 在类外部对静态数组images进行了定义和初始化
IMAGE* Block::images[7] = { NULL };
// 初始化方块大小
int Block::size = 36;

Block::Block() {

	// 第一次判断图片是否加载到静态数组，未加载则加载
	if (images[0] = NULL) {
		// 临时变量用于加载图片，进行切割
		IMAGE imgTmp;
		loadimage(&imgTmp,"res/tiles.png");
		// 切割
		SetWorkingImage(&imgTmp);
		for (size_t i = 0; i < 7; i++) {
			images[i] = new IMAGE();
			// 图片对象，切割的x，y，宽度，高度
			getimage(images[i], i*size,0,size,size);
		}
		// 恢复工作区
		SetWorkingImage(&imgTmp);

	}


	// 定义7中方块类型
	int blocks[7][4] = {
		1,3,5,7, // I
		2,4,5,7, // Z 1型
		3,5,4,6, // Z 2型
		3,5,4,7, // T
		2,3,5,7, // L
		3,5,7,6, // J
		2,3,4,5, // 田
	};

	// 随机生成一种
	this->blockType = rand() % 7 + 1;

	// 计算小方块的具体位置,每个大方块有4个小方块
	for (size_t i = 0; i < 4; i++) {
		int value = blocks[blockType][i];
		// 经过观察，方块的具体位置row为值除以2，col为值对2取余
		 this->smallBlocks[i].row = value / 2;
		 this->smallBlocks[i].col = value % 2;
		 this->img = images[blockType];
	}

}

void Block::drop() {
}

void Block::moveLeftRight(int offset) {
}

void Block::retate() {
}

void Block::draw(int leftMargin, int topMargin) {
}

```

在加载图片时可能报红，右键项目-属性-高级：

![image-20240320000927620](http://www.iocaop.com/images/2024-03/202403200011212.png)

### 06-绘制俄罗斯方块

```c++
void Block::draw(int leftMargin, int topMargin) {

	for (size_t i = 0; i < 4; i++) {
		int x = this->smallBlocks[i].col * size + leftMargin;
		int y = this->smallBlocks[i].row * size + topMargin;
		putimage(x, y, this->img);
	}

}
```

