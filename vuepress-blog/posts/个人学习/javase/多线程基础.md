---
title: java基础-多线程
date: 2023-06-19
category:
  - JavaSE
---

## 11-1-多线程

### 01-初步了解多线程

指从<span style="background-color:pink;">软件或者硬件</span>上实现<span style="background-color:pink;">多个线程并发执行</span>的技术。

具有多线程能力的计算机因为有硬件支持而能够在同一时间执行多个线程，提升性能。

![image-20230619215032599](http://www.iocaop.com/images/2023-06/202306192150650.png)

### 02-并发和并行

* 并行：在同一时刻，有多个指令在<span style="background-color:pink;">多个</span>cpu上<span style="background-color:pink;">同时</span>执行。
* 并发：在同一时刻，有多个指令在<span style="background-color:pink;">单个</span>cpu上<span style="background-color:pink;">交替</span>执行。

### 03-进程和线程

进程：正在运行的软件。最直观的，直接看任务管理器。

![image-20230619215450726](http://www.iocaop.com/images/2023-06/202306192154761.png)

进程的特点：

* 独立性：进程是一个能<span style="background-color:pink;">独立运行的基本单位</span>，也是系统<span style="background-color:pink;">分配资源</span>和<span style="background-color:pink;">调度</span>的独立单位。
* 动态性：进程实质是<span style="background-color:pink;">程序的一次执行过程</span>，进程是<span style="background-color:pink;">动态产生动态消亡</span>的。
* 并发性：任何进程都可以<span style="background-color:pink;">同其他进程一起并发执行</span>。

线程：是进程中的单个顺序控制流，是一条执行路径。

简单来说，火绒是一个进程，里面的垃圾清理，病毒查杀等功能，是火绒这个进程下的线程，他们可以同时执行。

* 单线程：一个进程如果只有一条执行路径，则称为单线程程序。
* 多线程：一个进程如果有多条执行路径，则称为多线程程序。

### 04~07-多线程的实现方式

先学三种实现方式：

* 继承`Thread`类

  ```java
  public class MyThread extends Thread{
      @Override
      public void run() {
          // 自定义一个类，重写run方法，线程开启后，就会执行run方法
          for (int i = 0; i < 100; i++) {
              System.out.println("打印："+i);
          }
      }
  }
  ```

  ```java
  public class MyThreadRunDemo {
      public static void main(String[] args) {
          // 创建两个线程对象
          MyThread t1 = new MyThread();
          MyThread t2 = new MyThread();
          // 用start方法开启线程
          t1.start();
          t2.start();
      }
  }
  
  ```

  看结果可以知道，这两条线程是并发执行的，并且由于cpu上下文切换的随机性，每次运行结果可能都不一样。

  > 为什么要重写run方法？因为线程执行以后，要执行run方法，run方法是用来封装线程需要执行的代码用的。
  >
  > run方法和start方法的区别？通过打印线程名称或者id可以得出，调用run方法是由调用的线程执行的，并没有开启新的方法。而start方法是新开一个线程去执行，开启新线程的方法是由c++实现的，在Java中属于本地方法(native)，源码中可以找到，方法名是start0。

  ![image-20230619221020867](http://www.iocaop.com/images/2023-06/202306192210893.png)

* 实现`Runnable`接口

  ```java
  public class MyRunnableRunDemo {
      public static void main(String[] args) {
          MyRunnable runnable = new MyRunnable();
          // 需要注意的时，runnable中没有start方法，需要将runnable对象作为参数，传递给Thread的构造,来启动线程
          Thread t1 = new Thread(runnable);
          Thread t2 = new Thread(runnable);
          t1.start();
          t2.start();
      }
  }
  ```

  ![image-20230619223019198](http://www.iocaop.com/images/2023-06/202306192230220.png)

* `Callable`和`Future`接口实现

  ```java
  public class MyCallable implements Callable<String> {
  
  
      /**
       * 和run方法一样，是线程执行代码的封装方法
       * 返回值是实现Callable时所指定的泛型，这里是String，意味着线程执行call方法，返回结果也是String类型
       *
       * @return {@link String}
       * @throws Exception 异常
       */
      @Override
      public String call() throws Exception {
          for (int i = 0; i < 100; i++) {
              System.out.println("打印："+i);
          }
          return "call执行完毕";
      }
  }
  
  ```

  ```java
  public class MyCallableRunDemo {
      public static void main(String[] args) throws ExecutionException, InterruptedException {
          // 线程开启后，会调用该对象的call方法，执行封装好的代码
          MyCallable myCallable = new MyCallable();
          // 可以获取call方法的返回结果，同时作为参数传递给Thread的构造
          FutureTask<String> futureTask = new FutureTask<>(myCallable);
          // 创建线程对象
          Thread thread = new Thread(futureTask);
          // 开启线程
          thread.start();
          // 获取线程执行的结果
          String s = futureTask.get();
          System.out.println("线程执行的结果:"+s);
      }
  }
  ```

  为什么创建线程的时候不能直接传递`Callable`实现类的对象呢？因为`Thread`的构造需要的是`Runnable`接口的实现类对象，而`Callable`没有实现`Runnable`接口，`FutureTask`实现了`Runnable`接口：

  ![image-20230619223850027](http://www.iocaop.com/images/2023-06/202306192238074.png)

![image-20230619223903642](http://www.iocaop.com/images/2023-06/202306192239663.png)

执行结果：

![image-20230619224547900](http://www.iocaop.com/images/2023-06/202306192245921.png)

思考一个问题：如果在`start()`方法调用执行使用`FutureTask`的`get()`方法，会发生什么？

没有任何结果，但是`main`方法也没有停止。`get()`方法是获取线程执行的结果，如果线程还没有启动运行，那么`get()`方法会一直等着。

### 08-三种实现方式的对比

![image-20230619225157623](http://www.iocaop.com/images/2023-06/202306192251661.png)

### 09-Thread方法-设置、获取线程名称

获取线程名称：

```java
public class MyThread extends Thread{
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            // 调用Thread中继承过来的方法获取线程名称
            System.out.println(super.getName()+"打印："+i);
        }
    }
}
```

```java
public class MyThreadDemo {
    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        myThread.start();
    }
}
```

![image-20230619225756142](http://www.iocaop.com/images/2023-06/202306192257163.png)

线程是有默认名字的，格式为`Thread-编号`，源码中可以看出：

![image-20230619230023319](http://www.iocaop.com/images/2023-06/202306192300341.png)

![image-20230619230037480](http://www.iocaop.com/images/2023-06/202306192300516.png)

设置线程名称：

方式1：调用set方法

```java
public class MyThreadDemo {
    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        myThread.setName("我的线程1");
        myThread.start();
    }
}
```

方式2：构造方法传入

```java
public class MyThreadDemo {
    public static void main(String[] args) {
        MyThread myThread = new MyThread("我的线程1");
        myThread.start();
    }
}
```

```java
public class MyThread extends Thread{

    public MyThread(String name) {
        super(name);
    }

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            // 调用Thread中继承过来的方法获取线程名称
            System.out.println(super.getName()+"打印："+i);
        }
    }
}
```

### 10-Thread方法-获取当前线程对象

![image-20230619230506472](http://www.iocaop.com/images/2023-06/202306192305501.png)

获取当前线程对象，当前线程是由哪个线程执行，就会返回哪个线程的对象。

### 11-Thread方法-sleep

![image-20230619230646498](http://www.iocaop.com/images/2023-06/202306192306526.png)

让线程休眠，哪条线程执行到了这个方法，就会将哪条线程进行休眠，参数是休眠时间，单位是毫秒。

会抛出异常，处理异常的线程是调用线程(谁调用了`Thread.sleep()`这个异常就是谁处理)。

### 12-线程调度-线程的优先级

多线程的并发：

计算机中的cpu在任一时刻只能执行一条及其指令，每个线程只有获得cpu的使用权才能执行任务，<span style="background-color:pink;">各个线程轮流获得cpu的执行权</span>，分别执行各自的任务。

两种调度模型：

* 分时调度模型：所有线程轮流使用cpu，<span style="background-color:pink;">平均分配</span>每个线程占用cpu的时间片。

* 抢占式调度模型：<span style="background-color:pink;">优先让优先级高的线程使用cpu</span>，优先级相同则随机，这样以来，优先级高的线程，获取cpu的时间片相对多一些。

<span style="background-color:pink;">Java中使用的是抢占式调度模型</span>

Java中可以设置线程的优先级：`Thread`类的源码

![image-20230619231644709](http://www.iocaop.com/images/2023-06/202306192316739.png)

默认优先级是5，最大10，最小1。

线程优先级越高，只能说明他抢到cpu使用权的几率更高，不意味着他先执行。

### 13-Thread方法-守护线程

又叫后台线程。

普通线程执行完毕了，守护线程也会停止运行：`Thread`源码

![image-20230619232351246](http://www.iocaop.com/images/2023-06/202306192323272.png)

守护线程的意义是什么？守护普通线程

比如qq传文件，传到一般，我把整个qq退出了。那传输文件的线程就是守护线程，整个qq退出了，守护线程传文件就没必要存在了。

写个demo，普通线程循环打印10次，守护线程循环打印100次，普通线程打印完10次，守护线程会继续执行吗？

```java
public class MyThread01 extends Thread{
    @Override
    public void run() {
        super.setName("普通线程");
        for (int i = 0; i < 10; i++) {
            System.out.println(super.getName()+"---"+i);
        }
    }
}
```

```java
public class MyThread02 extends Thread{
    @Override
    public void run() {
        super.setName("守护线程");
        for (int i = 0; i < 100; i++) {
            System.out.println(super.getName()+"---"+i);
        }
    }
}

```

```java
public class MyDaemonRunDemo {
    public static void main(String[] args) {
        MyThread01 myThread01 = new MyThread01();
        MyThread02 myThread02 = new MyThread02();
        // 设置为守护线程
        myThread02.setDaemon(true);

        myThread01.start();
        myThread02.start();

    }
}
```

![image-20230619233256813](http://www.iocaop.com/images/2023-06/202306192332837.png)

结果可以看出，当普通线程执行完毕后，守护线程并不会继续执行了。但也不会马上停止，因为他还占用着cpu，要过一会再停止。

## 11-2线程安全问题

### 14-卖票案例实现

多个线程同时操作共享资源，就会有线程安全问题。

需求：某电影院上映国产大片，一共100张票，有3个卖票窗口，编程模拟卖票。

思路：实现`Runnable`接口，run方法卖票，成员变量表示余票。三个窗口线程使用相同的`Runnable`对象，保证100张票是共享的。

```java
public class Ticket implements Runnable{

    private Integer count=100;

    @Override
    public void run() {
        while (true){
            if (count<=0){
                throw new RuntimeException("卖完啦");
            }
            this.count--;
            System.out.println(Thread.currentThread().getName()+"卖出一张票，还剩："+this.count+"张");
        }
    }
}
```

```java
public class MyTicketRunDemo {
    public static void main(String[] args) {
        Ticket ticket = new Ticket();
        Thread t1 = new Thread(ticket);
        Thread t2 = new Thread(ticket);
        Thread t3 = new Thread(ticket);

        t1.setName("窗口1");
        t2.setName("窗口2");
        t3.setName("窗口3");

        t1.start();
        t2.start();
        t3.start();
    }
}

```

运行：

![image-20230619235804690](http://www.iocaop.com/images/2023-06/202306192358722.png)

> 结合我所学的知识，已经看出问题，在抛出异常的if这里，cpu执行时，if并不是一条指令，会被编译成多条指令，有一种可能，当售票到最后一张票(不是最后一张也行，Redis的自增自减是原子操作，java中的i--不是原子操作，<a href='https://blog.csdn.net/qq_39835588/article/details/82933777?spm=1001.2101.3001.6650.17&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-17-82933777-blog-123495656.235%5Ev38%5Epc_relevant_default_base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-17-82933777-blog-123495656.235%5Ev38%5Epc_relevant_default_base&utm_relevant_index=18'>点击跳转</a>，一样会超卖)，当判断指令(jcc指令)刚走完，还没来得及自减，cpu就调度了，执行另一个线程的指令了，此时count会被多个线程自减多次即使他已经小于等于0了(因为判断已经走完了)，导致超卖。

### 15-卖票案例并发问题原因分析

结合生活实际，售票出票需要时间，我们给线程加点延迟，每次出票时间是100毫秒，即每次自减，睡眠100毫秒，看看会怎么样？

```java
public class Ticket implements Runnable{

    private Integer count=100;

    @Override
    public void run() {
        while (true){
            if (count<=0){
                throw new RuntimeException("卖完啦");
            }
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            this.count--;
            System.out.println(Thread.currentThread().getName()+"卖出一张票，还剩："+this.count+"张");
        }
    }
}
```

看结果：出现了负数，甚至抛出了两次异常

![image-20230620002028101](http://www.iocaop.com/images/2023-06/202306200020134.png)

情况1：重复票

线程1执行到打印语句之前是99，切到线程2，又走到打印语句前是98，切到线程3，又走到打印语句前是97，这是线程1、线程2、线程3都走打印语句。打出来三个都是97.重复票。

情况2：超卖，负号票

和我上面14节课说的一样，线程1、线程2、线程3都走到自减之前，cpu调度了，导致超卖。



