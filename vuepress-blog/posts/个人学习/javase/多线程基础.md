---
title: java基础-多线程
date: 2023-06-19
category:
  - JavaSE
---

## 11-1-多线程

### 01-初步了解多线程

指从<span style="background-color:pink;">软件或者硬件</span>上实现<span style="background-color:pink;">多个线程并发执行</span>的技术。

具有多线程能力的计算机因为有硬件支持而能够在同一时间执行多个线程，提升性能。

![image-20230619215032599](http://www.iocaop.com/images/2023-06/202306192150650.png)

### 02-并发和并行

* 并行：在同一时刻，有多个指令在<span style="background-color:pink;">多个</span>cpu上<span style="background-color:pink;">同时</span>执行。
* 并发：在同一时刻，有多个指令在<span style="background-color:pink;">单个</span>cpu上<span style="background-color:pink;">交替</span>执行。

### 03-进程和线程

进程：正在运行的软件。最直观的，直接看任务管理器。

![image-20230619215450726](http://www.iocaop.com/images/2023-06/202306192154761.png)

进程的特点：

* 独立性：进程是一个能<span style="background-color:pink;">独立运行的基本单位</span>，也是系统<span style="background-color:pink;">分配资源</span>和<span style="background-color:pink;">调度</span>的独立单位。
* 动态性：进程实质是<span style="background-color:pink;">程序的一次执行过程</span>，进程是<span style="background-color:pink;">动态产生动态消亡</span>的。
* 并发性：任何进程都可以<span style="background-color:pink;">同其他进程一起并发执行</span>。

线程：是进程中的单个顺序控制流，是一条执行路径。

简单来说，火绒是一个进程，里面的垃圾清理，病毒查杀等功能，是火绒这个进程下的线程，他们可以同时执行。

* 单线程：一个进程如果只有一条执行路径，则称为单线程程序。
* 多线程：一个进程如果有多条执行路径，则称为多线程程序。

### 04~07-多线程的实现方式

先学三种实现方式：

* 继承`Thread`类

  ```java
  public class MyThread extends Thread{
      @Override
      public void run() {
          // 自定义一个类，重写run方法，线程开启后，就会执行run方法
          for (int i = 0; i < 100; i++) {
              System.out.println("打印："+i);
          }
      }
  }
  ```

  ```java
  public class MyThreadRunDemo {
      public static void main(String[] args) {
          // 创建两个线程对象
          MyThread t1 = new MyThread();
          MyThread t2 = new MyThread();
          // 用start方法开启线程
          t1.start();
          t2.start();
      }
  }
  
  ```

  看结果可以知道，这两条线程是并发执行的，并且由于cpu上下文切换的随机性，每次运行结果可能都不一样。

  > 为什么要重写run方法？因为线程执行以后，要执行run方法，run方法是用来封装线程需要执行的代码用的。
  >
  > run方法和start方法的区别？通过打印线程名称或者id可以得出，调用run方法是由调用的线程执行的，并没有开启新的方法。而start方法是新开一个线程去执行，开启新线程的方法是由c++实现的，在Java中属于本地方法(native)，源码中可以找到，方法名是start0。

  ![image-20230619221020867](http://www.iocaop.com/images/2023-06/202306192210893.png)

* 实现`Runnable`接口

  ```java
  public class MyRunnableRunDemo {
      public static void main(String[] args) {
          MyRunnable runnable = new MyRunnable();
          // 需要注意的时，runnable中没有start方法，需要将runnable对象作为参数，传递给Thread的构造,来启动线程
          Thread t1 = new Thread(runnable);
          Thread t2 = new Thread(runnable);
          t1.start();
          t2.start();
      }
  }
  ```

  ![image-20230619223019198](http://www.iocaop.com/images/2023-06/202306192230220.png)

* `Callable`和`Future`接口实现

  ```java
  public class MyCallable implements Callable<String> {
  
  
      /**
       * 和run方法一样，是线程执行代码的封装方法
       * 返回值是实现Callable时所指定的泛型，这里是String，意味着线程执行call方法，返回结果也是String类型
       *
       * @return {@link String}
       * @throws Exception 异常
       */
      @Override
      public String call() throws Exception {
          for (int i = 0; i < 100; i++) {
              System.out.println("打印："+i);
          }
          return "call执行完毕";
      }
  }
  
  ```

  ```java
  public class MyCallableRunDemo {
      public static void main(String[] args) throws ExecutionException, InterruptedException {
          // 线程开启后，会调用该对象的call方法，执行封装好的代码
          MyCallable myCallable = new MyCallable();
          // 可以获取call方法的返回结果，同时作为参数传递给Thread的构造
          FutureTask<String> futureTask = new FutureTask<>(myCallable);
          // 创建线程对象
          Thread thread = new Thread(futureTask);
          // 开启线程
          thread.start();
          // 获取线程执行的结果
          String s = futureTask.get();
          System.out.println("线程执行的结果:"+s);
      }
  }
  ```

  为什么创建线程的时候不能直接传递`Callable`实现类的对象呢？因为`Thread`的构造需要的是`Runnable`接口的实现类对象，而`Callable`没有实现`Runnable`接口，`FutureTask`实现了`Runnable`接口：

  ![image-20230619223850027](http://www.iocaop.com/images/2023-06/202306192238074.png)

![image-20230619223903642](http://www.iocaop.com/images/2023-06/202306192239663.png)

执行结果：

![image-20230619224547900](http://www.iocaop.com/images/2023-06/202306192245921.png)

思考一个问题：如果在`start()`方法调用执行使用`FutureTask`的`get()`方法，会发生什么？

没有任何结果，但是`main`方法也没有停止。`get()`方法是获取线程执行的结果，如果线程还没有启动运行，那么`get()`方法会一直等着。

### 08-三种实现方式的对比

![image-20230619225157623](http://www.iocaop.com/images/2023-06/202306192251661.png)

### 09-Thread方法-设置、获取线程名称

获取线程名称：

```java
public class MyThread extends Thread{
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            // 调用Thread中继承过来的方法获取线程名称
            System.out.println(super.getName()+"打印："+i);
        }
    }
}
```

```java
public class MyThreadDemo {
    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        myThread.start();
    }
}
```

![image-20230619225756142](http://www.iocaop.com/images/2023-06/202306192257163.png)

线程是有默认名字的，格式为`Thread-编号`，源码中可以看出：

![image-20230619230023319](http://www.iocaop.com/images/2023-06/202306192300341.png)

![image-20230619230037480](http://www.iocaop.com/images/2023-06/202306192300516.png)

设置线程名称：

方式1：调用set方法

```java
public class MyThreadDemo {
    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        myThread.setName("我的线程1");
        myThread.start();
    }
}
```

方式2：构造方法传入

```java
public class MyThreadDemo {
    public static void main(String[] args) {
        MyThread myThread = new MyThread("我的线程1");
        myThread.start();
    }
}
```

```java
public class MyThread extends Thread{

    public MyThread(String name) {
        super(name);
    }

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            // 调用Thread中继承过来的方法获取线程名称
            System.out.println(super.getName()+"打印："+i);
        }
    }
}
```

### 10-Thread方法-获取当前线程对象

![image-20230619230506472](http://www.iocaop.com/images/2023-06/202306192305501.png)

获取当前线程对象，当前线程是由哪个线程执行，就会返回哪个线程的对象。

### 11-Thread方法-sleep

![image-20230619230646498](http://www.iocaop.com/images/2023-06/202306192306526.png)

让线程休眠，哪条线程执行到了这个方法，就会将哪条线程进行休眠，参数是休眠时间，单位是毫秒。

会抛出异常，处理异常的线程是调用线程(谁调用了`Thread.sleep()`这个异常就是谁处理)。

### 12-线程调度-线程的优先级

多线程的并发：

计算机中的cpu在任一时刻只能执行一条及其指令，每个线程只有获得cpu的使用权才能执行任务，<span style="background-color:pink;">各个线程轮流获得cpu的执行权</span>，分别执行各自的任务。

两种调度模型：

* 分时调度模型：所有线程轮流使用cpu，<span style="background-color:pink;">平均分配</span>每个线程占用cpu的时间片。

* 抢占式调度模型：<span style="background-color:pink;">优先让优先级高的线程使用cpu</span>，优先级相同则随机，这样以来，优先级高的线程，获取cpu的时间片相对多一些。

<span style="background-color:pink;">Java中使用的是抢占式调度模型</span>

Java中可以设置线程的优先级：`Thread`类的源码

![image-20230619231644709](http://www.iocaop.com/images/2023-06/202306192316739.png)

默认优先级是5，最大10，最小1。

线程优先级越高，只能说明他抢到cpu使用权的几率更高，不意味着他先执行。

### 13-Thread方法-守护线程

又叫后台线程。

普通线程执行完毕了，守护线程也会停止运行：`Thread`源码

![image-20230619232351246](http://www.iocaop.com/images/2023-06/202306192323272.png)

守护线程的意义是什么？守护普通线程

比如qq传文件，传到一般，我把整个qq退出了。那传输文件的线程就是守护线程，整个qq退出了，守护线程传文件就没必要存在了。

写个demo，普通线程循环打印10次，守护线程循环打印100次，普通线程打印完10次，守护线程会继续执行吗？

```java
public class MyThread01 extends Thread{
    @Override
    public void run() {
        super.setName("普通线程");
        for (int i = 0; i < 10; i++) {
            System.out.println(super.getName()+"---"+i);
        }
    }
}
```

```java
public class MyThread02 extends Thread{
    @Override
    public void run() {
        super.setName("守护线程");
        for (int i = 0; i < 100; i++) {
            System.out.println(super.getName()+"---"+i);
        }
    }
}

```

```java
public class MyDaemonRunDemo {
    public static void main(String[] args) {
        MyThread01 myThread01 = new MyThread01();
        MyThread02 myThread02 = new MyThread02();
        // 设置为守护线程
        myThread02.setDaemon(true);

        myThread01.start();
        myThread02.start();

    }
}
```

![image-20230619233256813](http://www.iocaop.com/images/2023-06/202306192332837.png)

结果可以看出，当普通线程执行完毕后，守护线程并不会继续执行了。但也不会马上停止，因为他还占用着cpu，要过一会再停止。

## 11-2线程安全问题

### 14-卖票案例实现

多个线程同时操作共享资源，就会有线程安全问题。

需求：某电影院上映国产大片，一共100张票，有3个卖票窗口，编程模拟卖票。

思路：实现`Runnable`接口，run方法卖票，成员变量表示余票。三个窗口线程使用相同的`Runnable`对象，保证100张票是共享的。

```java
public class Ticket implements Runnable{

    private Integer count=100;

    @Override
    public void run() {
        while (true){
            if (count<=0){
                throw new RuntimeException("卖完啦");
            }
            this.count--;
            System.out.println(Thread.currentThread().getName()+"卖出一张票，还剩："+this.count+"张");
        }
    }
}
```

```java
public class MyTicketRunDemo {
    public static void main(String[] args) {
        Ticket ticket = new Ticket();
        Thread t1 = new Thread(ticket);
        Thread t2 = new Thread(ticket);
        Thread t3 = new Thread(ticket);

        t1.setName("窗口1");
        t2.setName("窗口2");
        t3.setName("窗口3");

        t1.start();
        t2.start();
        t3.start();
    }
}

```

运行：

![image-20230619235804690](http://www.iocaop.com/images/2023-06/202306192358722.png)

> 结合我所学的知识，已经看出问题，在抛出异常的if这里，cpu执行时，if并不是一条指令，会被编译成多条指令，有一种可能，当售票到最后一张票(不是最后一张也行，Redis的自增自减是原子操作，java中的i--不是原子操作，<a href='https://blog.csdn.net/qq_39835588/article/details/82933777?spm=1001.2101.3001.6650.17&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-17-82933777-blog-123495656.235%5Ev38%5Epc_relevant_default_base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-17-82933777-blog-123495656.235%5Ev38%5Epc_relevant_default_base&utm_relevant_index=18'>点击跳转</a>，一样会超卖)，当判断指令(jcc指令)刚走完，还没来得及自减，cpu就调度了，执行另一个线程的指令了，此时count会被多个线程自减多次即使他已经小于等于0了(因为判断已经走完了)，导致超卖。

### 15-卖票案例并发问题原因分析

结合生活实际，售票出票需要时间，我们给线程加点延迟，每次出票时间是100毫秒，即每次自减，睡眠100毫秒，看看会怎么样？

```java
public class Ticket implements Runnable{

    private Integer count=100;

    @Override
    public void run() {
        while (true){
            if (count<=0){
                throw new RuntimeException("卖完啦");
            }
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            this.count--;
            System.out.println(Thread.currentThread().getName()+"卖出一张票，还剩："+this.count+"张");
        }
    }
}
```

看结果：出现了负数

![image-20230620002028101](http://www.iocaop.com/images/2023-06/202306200020134.png)

情况1：重复票

线程1执行到打印语句之前是99，切到线程2，又走到打印语句前是98，切到线程3，又走到打印语句前是97，这是线程1、线程2、线程3都走打印语句。打出来三个都是97.重复票。

情况2：超卖，负号票

和我上面14节课说的一样，线程1、线程2、线程3都走到自减之前，cpu调度了，导致超卖。

### 16-同步代码块

我们看看，操作共享数据的代码是哪块：从判断语句就开始了，直到打印语句。

![image-20230620003410812](http://www.iocaop.com/images/2023-06/202306200034844.png)

思考：如果操作共享数据时，只让一条线程操作，等这条数据操作完了，其他线程再操作，是不是就解决了上面的两个问题？

* 为什么出现问题？

  多线程操作共享数据

* 如何解决多线程安全问题？

  基本思想：让程序没有安全问题的环境

* 怎么实现？

  多条语句操作共享数据的代码锁起来，让任意时刻只能有一个线程执行。

同步代码块：

```java
synchronized(任意对象){多条语句操作共享数据的代码}
```

默认情况，这个锁是打开的，只要有一个线程进去执行代码了，锁就会关闭。当线程执行完毕出来了，锁才会自动打开。

锁的好处和弊端：

好处是解决了多线程的数据安全问题。

坏处是影响性能，线程很多，都会访问同步上的锁，耗费资源。

实现：修改run方法，加锁。

```java
    @Override
    public void run() {
        while (true){
            synchronized (this){
                if (count<=0){
                    throw new RuntimeException("卖完啦");
                }
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                this.count--;
                System.out.println(Thread.currentThread().getName()+"卖出一张票，还剩："+this.count+"张");
            }
        }
    }
```

加锁后运行，不会出现重复票和负号票：

![image-20230620004552584](http://www.iocaop.com/images/2023-06/202306200045625.png)

### 17-锁对象的唯一

将上面的卖票案例改写，不使用`Runnable`，而是直接继承`Thread`类：

```java
public class TicketThread extends Thread{
    private Integer count=100;

    @Override
    public void run() {
        while (true){
            synchronized (this){
                if (count<=0){
                    throw new RuntimeException("卖完啦");
                }
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                this.count--;
                System.out.println(Thread.currentThread().getName()+"卖出一张票，还剩："+this.count+"张");
            }
        }
    }
}

```

```java
public class MyTicketRunDemo {
    public static void main(String[] args) {
        Thread t1 = new TicketThread();
        Thread t2 = new TicketThread();
        Thread t3 = new TicketThread();

        t1.setName("窗口1");
        t2.setName("窗口2");
        t3.setName("窗口3");

        t1.start();
        t2.start();
        t3.start();
    }
}
```

运行发现，每张票都是重复票，原因：count不是共享数据，需要加`static`：

```java
    private static Integer count=100;
```

修改后运行发现：出现负号票，原因，锁不是唯一的，使用的是`this`,是线程对象，三个窗口各自有各自的对象，锁不唯一

![image-20230620005621838](http://www.iocaop.com/images/2023-06/202306200056876.png)

将锁改为唯一的：

```java
 synchronized (this.getClass())
```

运行结果正常：

![image-20230620005809893](http://www.iocaop.com/images/2023-06/202306200058926.png)

### 18-同步方法

同步方法：就是把`synchronized`关键字加到方法上。

格式：

```java
修饰符 synchronized 返回值类型 方法名(方法参数){}
```

同步代码块和同步方法的区别：

* 同步代码块是锁住指定的方法，同步方法是锁住方法中所有的代码。
* <span style="background-color:pink;">同步代码块可以指定锁对象，同步方法不能指定锁对象。</span>

同步方法的锁对象是谁？是`this`。

将上面的售票案例，改为窗口1使用同步方法，窗口2使用同步代码块：

```java
/**
 * 同步方法和同步代码块
 *
 * @author 赖卓成
 * @date 2023/06/21
 */
public class MyRunnable implements Runnable {

    public static int count = 100;

    @Override
    public void run() {
        while (true) {
            if ("窗口1".equals(Thread.currentThread().getName())) {
                boolean empty = this.syncMethod();
                if (empty) {
                    break;
                }
            }

            if ("窗口2".equals(Thread.currentThread().getName())) {
                // 同步代码块
                synchronized (new Object()) {
                    if (count <= 0) {
                        break;
                    }
                    try {
                        Thread.sleep(100L);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                    count--;
                    System.out.println(Thread.currentThread().getName() + "卖出一张票，还剩：" + count + "张");
                }
            }
        }
    }

    /**
     * 同步方法
     *
     * @return boolean
     */
    private synchronized boolean syncMethod() {
        if (count <= 0) {
            return true;
        }
        try {
            Thread.sleep(100L);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        count--;
        System.out.println(Thread.currentThread().getName() + "卖出一张票，还剩：" + count + "张");
        return false;
    }
}
```

```java
/**
 * 同步方法和同步代码块
 *
 * @author 赖卓成
 * @date 2023/06/21
 */
public class MyRunnableRunDemo {

    public static void main(String[] args) {
        MyRunnable myRunnable = new MyRunnable();
        Thread t1 = new Thread(myRunnable);
        Thread t2 = new Thread(myRunnable);

        t1.setName("窗口1");
        t2.setName("窗口2");

        t1.start();
        t2.start();
    }

}

```

### 19-Lock

上面两节使用了`synchronized`，同步方法和同步代码块。我们可以理解他加了锁，但是却看不到他在哪里加了锁，哪里释放了锁，为了更清楚地表达如何加锁、释放锁，jdk5以后提供了一个新的锁对象`Lock`。

`Lock`提供了比使用`synchronized`方法和语句可以获得更广泛的锁定操作。

* void lock()：获得锁
* void unlock()：释放锁

`Lock`是接口，不能直接实例化，这里才用它的实现类`ReentrantLock`来实例化。

这里先简单使用一下`ReentrantLock`,改写之前的售票案例：

```java
public class TicketThread extends Thread {
    private static Integer count = 100;
    /**
     * 为了多个线程使用同一把锁，需要将锁定义为静态变量
     */
    private static ReentrantLock lock = new ReentrantLock();
    @Override
    public void run() {

        while (true) {
            lock.lock();
            if (count <= 0) {
                throw new RuntimeException("卖完啦");
            }
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            count--;
            System.out.println(Thread.currentThread().getName() + "卖出一张票，还剩：" + count + "张");
            lock.unlock();
        }

    }
}
```

```java
public class MyTicketRunDemo {
    public static void main(String[] args) {
        Thread t1 = new TicketThread();
        Thread t2 = new TicketThread();
        Thread t3 = new TicketThread();

        t1.setName("窗口1");
        t2.setName("窗口2");
        t3.setName("窗口3");

        t1.start();
        t2.start();
        t3.start();
    }
}

```

运行结果正确：

![image-20230626203832864](http://www.iocaop.com/images/2023-06/202306262038906.png)

### 20-死锁

死锁是指两个或多个线程相互持有对方所需要的资源，导致这些资源处于等待状态，无法继续往前执行。

课程中的例子：

![image-20230626204340032](http://www.iocaop.com/images/2023-06/202306262043066.png)

![image-20230626204356124](http://www.iocaop.com/images/2023-06/202306262043173.png)

![image-20230626204454455](http://www.iocaop.com/images/2023-06/202306262044509.png)

代码实现：

```java
/**
 * 死锁
 *
 * @author lzc
 * @date 2023/06/26
 */
public class DeadLock {

    public static void main(String[] args) {
        // 创建两把锁
        Object lockA = new Object();
        Object lockB = new Object();

        new Thread(()->{
           while (true){
               synchronized (lockA){
                   synchronized (lockB){
                       System.out.println(new Date()+"线程1获取了两把锁");
                   }
               }
           }
        }).start();

        new Thread(()->{
            while (true){
                synchronized (lockB){
                    synchronized (lockA){
                        System.out.println(new Date()+"线程2获取了两把锁");
                    }
                }
            }
        }).start();
    }
}

```

线程1先获取锁A，再获取锁B。线程2先获取锁B，再获取锁A。

有一种情况，就是线程1获取锁A或，cpu切换到线程2，线程2获取了锁B，导致线程1无法获取锁B，而线程2需要的锁A又被线程1获取了。两个线程互相等待，导致死锁。<span style="background-color:pink;">打印了一段时间后，就不再打印了，但是程序没有停止。</span>

![image-20230626205302448](http://www.iocaop.com/images/2023-06/202306262053484.png)

> 如何解决？不要嵌套使用锁就好了。

## 11-3-生产者和消费者

### 21-思路分析

生产者生产出来的东西，给消费者消费。课程中的例子：厨师生产汉堡，放到桌子上，吃货来吃。

![image-20230626212414393](http://www.iocaop.com/images/2023-06/202306262124444.png)

吃货线程和厨师线程需要轮流执行。

厨师：

* 判断桌子上是否有汉堡，有则等待，没有则生产
* 把汉堡放桌上
* 叫醒吃货吃汉堡

吃货：

- 判断桌子上是否有汉堡
- 没有则等待
- 如果有就吃
- 吃完后，桌上没了
- 叫醒等待的厨师继续生产

### 22-代码实现

为了体现生产和消费过程的<span style="background-color:pink;">等待</span>和<span style="background-color:pink;">唤醒</span>，Java在Object类提供了方法：

![image-20230626212704722](http://www.iocaop.com/images/2023-06/202306262127763.png)

```java
/**
 * 厨师线程
 *
 * @author lzc
 * @date 2023/06/26
 */
public class Cooker extends Thread {

    @Override
    public void run() {
        // 死循环
        while (true) {
            // 获取锁
            synchronized (Desk.lock) {
                // 是否生产够了10个
                if (Desk.count <= 0) {
                    break;
                }
                // 桌子上是否有汉堡
                if (Desk.flag) {
                    // 有则等待
                    try {
                        Desk.lock.wait();
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                } else {
                    // 没有则生产,将标志设置为有
                    Desk.flag = true;
                    // 生产者这里不处理count了,在消费者处理一次即可。
                    System.out.println("厨师已经生产了第" + (1001 - Desk.count) + "个汉堡！");
                    // 通知吃货来吃,这里我们只开启了一个吃货和一个厨师，所以不使用notifyAll()
                    Desk.lock.notify();
                }
            }
        }

    }
}
```

```java
/**
 * 吃货线程
 *
 * @author lzc
 * @date 2023/06/26
 */
public class Foodie extends Thread {
    @Override
    public void run() {
        // 死循环
        while (true) {
            // 获取锁
            synchronized (Desk.lock) {
                // 吃够了10个没有
                if (Desk.count <= 0) {
                    break;
                }
                // 桌子上是否有汉堡
                if (Desk.flag) {
                    // 有则吃
                    System.out.println("吃货吃完了第" + (1001 - Desk.count) + "个汉堡");
                    // 数量减1
                    Desk.count--;
                    // 修改标记
                    Desk.flag = false;
                    // 通知厨师生产汉堡
                    Desk.lock.notify();
                } else {
                    //没有汉堡则等待,需要注意的是，这里调用wait方法的锁，需要生产者和消费者是同一把锁，也就是同一个对象去调用
                    try {
                        Desk.lock.wait();
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                }
            }

        }
    }
}

```

```java
/**
 * 桌子
 *
 * @author lzc
 * @date 2023/06/26
 */
public class Desk {

    /**
     * 汉堡数量
     */
    public static int count = 1000;

    /**
     * 锁
     */
    public static Object lock = new Object();

    /**
     * 标志、桌子上是否有汉堡
     */
    public static boolean flag = false;

    public static void main(String[] args) {
        Cooker cooker = new Cooker();
        Foodie foodie = new Foodie();
        cooker.start();
        foodie.start();
    }
}
```

运行结果：无论设置数量为多少，都是交替执行。

![image-20230626221528443](http://www.iocaop.com/images/2023-06/202306262215475.png)

> 需要注意，厨师生产完或吃货吃完，都需要调用使用锁对象调用`notify()`方法来通知其他线程。

### 23-代码改写

上面代码用的是简单的方式，我们改写一下，面向对象。

```java
/**
 * 桌子
 *
 * @author lzc
 * @date 2023/06/26
 */
@Data
@AllArgsConstructor
public class Desk {

    /**
     * 汉堡数量
     */
    private   int count = 1000;

    /**
     * 锁
     */
    private  Object lock = new Object();

    /**
     * 标志、桌子上是否有汉堡
     */
    private  boolean flag = false;


}

```

```java
/**
 * 厨师线程
 *
 * @author lzc
 * @date 2023/06/26
 */
@AllArgsConstructor
public class Cooker extends Thread {

    private Desk desk;

    @Override
    public void run() {
        // 死循环
        while (true) {
            // 获取锁
            synchronized (this.desk.getLock()) {
                // 是否生产够了10个
                if (this.desk.getCount()<= 0) {
                    break;
                }
                // 桌子上是否有汉堡
                if (this.desk.isFlag()) {
                    // 有则等待
                    try {
                       this.desk.getLock().wait();
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                } else {
                    // 没有则生产,将标志设置为有
                    this.desk.setFlag(true);
                    // 生产者这里不处理count了,在消费者处理一次即可。
                    System.out.println("厨师已经生产了第" + (1001 - this.desk.getCount()) + "个汉堡！");
                    // 通知吃货来吃,这里我们只开启了一个吃货和一个厨师，所以不使用notifyAll()
                    this.desk.getLock().notify();
                }
            }
        }

    }
}
```

```java
/**
 * 吃货线程
 *
 * @author lzc
 * @date 2023/06/26
 */
@AllArgsConstructor
public class Foodie extends Thread {

    private Desk desk;

    @Override
    public void run() {
        // 死循环
        while (true) {
            // 获取锁
            synchronized (this.desk.getLock()) {
                // 吃够了10个没有
                if (this.desk.getCount() <= 0) {
                    break;
                }
                // 桌子上是否有汉堡
                if (this.desk.isFlag()) {
                    // 有则吃
                    System.out.println("吃货吃完了第" + (1001 - this.desk.getCount()) + "个汉堡");
                    // 数量减1
                    this.desk.setCount(this.desk.getCount()-1);
                    // 修改标记
                    this.desk.setFlag(false);
                    // 通知厨师生产汉堡
                    this.desk.getLock().notify();
                } else {
                    //没有汉堡则等待,需要注意的是，这里调用wait方法的锁，需要生产者和消费者是同一把锁，也就是同一个对象去调用
                    try {
                        this.desk.getLock().wait();
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                }
            }

        }
    }
}
```

```java
public class Demo {

    public static void main(String[] args) {
        Desk desk = new Desk(1000, new Object(), false);
        Cooker cooker = new Cooker(desk);
        Foodie foodie = new Foodie(desk);
        cooker.start();
        foodie.start();
    }
}
```

### 24-阻塞队列-基本使用

阻塞队列实现等待唤醒机制。

还是上面的生产者消费者案例，只不过
