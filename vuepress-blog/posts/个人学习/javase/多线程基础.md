---
title: java基础-多线程
date: 2023-06-19
category:
  - JavaSE
---

## 11-1-多线程

### 01-初步了解多线程

指从<span style="background-color:pink;">软件或者硬件</span>上实现<span style="background-color:pink;">多个线程并发执行</span>的技术。

具有多线程能力的计算机因为有硬件支持而能够在同一时间执行多个线程，提升性能。

![image-20230619215032599](http://www.iocaop.com/images/2023-06/202306192150650.png)

### 02-并发和并行

* 并行：在同一时刻，有多个指令在<span style="background-color:pink;">多个</span>cpu上<span style="background-color:pink;">同时</span>执行。
* 并发：在同一时刻，有多个指令在<span style="background-color:pink;">单个</span>cpu上<span style="background-color:pink;">交替</span>执行。

### 03-进程和线程

进程：正在运行的软件。最直观的，直接看任务管理器。

![image-20230619215450726](http://www.iocaop.com/images/2023-06/202306192154761.png)

进程的特点：

* 独立性：进程是一个能<span style="background-color:pink;">独立运行的基本单位</span>，也是系统<span style="background-color:pink;">分配资源</span>和<span style="background-color:pink;">调度</span>的独立单位。
* 动态性：进程实质是<span style="background-color:pink;">程序的一次执行过程</span>，进程是<span style="background-color:pink;">动态产生动态消亡</span>的。
* 并发性：任何进程都可以<span style="background-color:pink;">同其他进程一起并发执行</span>。

线程：是进程中的单个顺序控制流，是一条执行路径。

简单来说，火绒是一个进程，里面的垃圾清理，病毒查杀等功能，是火绒这个进程下的线程，他们可以同时执行。

* 单线程：一个进程如果只有一条执行路径，则称为单线程程序。
* 多线程：一个进程如果有多条执行路径，则称为多线程程序。

### 04~07-多线程的实现方式

先学三种实现方式：

* 继承`Thread`类

  ```java
  public class MyThread extends Thread{
      @Override
      public void run() {
          // 自定义一个类，重写run方法，线程开启后，就会执行run方法
          for (int i = 0; i < 100; i++) {
              System.out.println("打印："+i);
          }
      }
  }
  ```

  ```java
  public class MyThreadRunDemo {
      public static void main(String[] args) {
          // 创建两个线程对象
          MyThread t1 = new MyThread();
          MyThread t2 = new MyThread();
          // 用start方法开启线程
          t1.start();
          t2.start();
      }
  }
  
  ```

  看结果可以知道，这两条线程是并发执行的，并且由于cpu上下文切换的随机性，每次运行结果可能都不一样。

  > 为什么要重写run方法？因为线程执行以后，要执行run方法，run方法是用来封装线程需要执行的代码用的。
  >
  > run方法和start方法的区别？通过打印线程名称或者id可以得出，调用run方法是由调用的线程执行的，并没有开启新的方法。而start方法是新开一个线程去执行，开启新线程的方法是由c++实现的，在Java中属于本地方法(native)，源码中可以找到，方法名是start0。

  ![image-20230619221020867](http://www.iocaop.com/images/2023-06/202306192210893.png)

* 实现`Runnable`接口

  ```java
  public class MyRunnableRunDemo {
      public static void main(String[] args) {
          MyRunnable runnable = new MyRunnable();
          // 需要注意的时，runnable中没有start方法，需要将runnable对象作为参数，传递给Thread的构造,来启动线程
          Thread t1 = new Thread(runnable);
          Thread t2 = new Thread(runnable);
          t1.start();
          t2.start();
      }
  }
  ```

  ![image-20230619223019198](http://www.iocaop.com/images/2023-06/202306192230220.png)

* `Callable`和`Future`接口实现

  ```java
  public class MyCallable implements Callable<String> {
  
  
      /**
       * 和run方法一样，是线程执行代码的封装方法
       * 返回值是实现Callable时所指定的泛型，这里是String，意味着线程执行call方法，返回结果也是String类型
       *
       * @return {@link String}
       * @throws Exception 异常
       */
      @Override
      public String call() throws Exception {
          for (int i = 0; i < 100; i++) {
              System.out.println("打印："+i);
          }
          return "call执行完毕";
      }
  }
  
  ```

  ```java
  public class MyCallableRunDemo {
      public static void main(String[] args) throws ExecutionException, InterruptedException {
          // 线程开启后，会调用该对象的call方法，执行封装好的代码
          MyCallable myCallable = new MyCallable();
          // 可以获取call方法的返回结果，同时作为参数传递给Thread的构造
          FutureTask<String> futureTask = new FutureTask<>(myCallable);
          // 创建线程对象
          Thread thread = new Thread(futureTask);
          // 开启线程
          thread.start();
          // 获取线程执行的结果
          String s = futureTask.get();
          System.out.println("线程执行的结果:"+s);
      }
  }
  ```

  为什么创建线程的时候不能直接传递`Callable`实现类的对象呢？因为`Thread`的构造需要的是`Runnable`接口的实现类对象，而`Callable`没有实现`Runnable`接口，`FutureTask`实现了`Runnable`接口：

  ![image-20230619223850027](http://www.iocaop.com/images/2023-06/202306192238074.png)

![image-20230619223903642](http://www.iocaop.com/images/2023-06/202306192239663.png)

执行结果：

![image-20230619224547900](http://www.iocaop.com/images/2023-06/202306192245921.png)

思考一个问题：如果在`start()`方法调用执行使用`FutureTask`的`get()`方法，会发生什么？

没有任何结果，但是`main`方法也没有停止。`get()`方法是获取线程执行的结果，如果线程还没有启动运行，那么`get()`方法会一直等着。