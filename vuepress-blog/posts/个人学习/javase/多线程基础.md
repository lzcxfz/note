---
title: java基础-多线程
date: 2023-06-19
category:
  - JavaSE
---

## 11-1-多线程

### 01-初步了解多线程

指从<span style="background-color:pink;">软件或者硬件</span>上实现<span style="background-color:pink;">多个线程并发执行</span>的技术。

具有多线程能力的计算机因为有硬件支持而能够在同一时间执行多个线程，提升性能。

![image-20230619215032599](http://www.iocaop.com/images/2023-06/202306192150650.png)

### 02-并发和并行

* 并行：在同一时刻，有多个指令在<span style="background-color:pink;">多个</span>cpu上<span style="background-color:pink;">同时</span>执行。
* 并发：在同一时刻，有多个指令在<span style="background-color:pink;">单个</span>cpu上<span style="background-color:pink;">交替</span>执行。

### 03-进程和线程

进程：正在运行的软件。最直观的，直接看任务管理器。

![image-20230619215450726](http://www.iocaop.com/images/2023-06/202306192154761.png)

进程的特点：

* 独立性：进程是一个能<span style="background-color:pink;">独立运行的基本单位</span>，也是系统<span style="background-color:pink;">分配资源</span>和<span style="background-color:pink;">调度</span>的独立单位。
* 动态性：进程实质是<span style="background-color:pink;">程序的一次执行过程</span>，进程是<span style="background-color:pink;">动态产生动态消亡</span>的。
* 并发性：任何进程都可以<span style="background-color:pink;">同其他进程一起并发执行</span>。

线程：是进程中的单个顺序控制流，是一条执行路径。

简单来说，火绒是一个进程，里面的垃圾清理，病毒查杀等功能，是火绒这个进程下的线程，他们可以同时执行。

* 单线程：一个进程如果只有一条执行路径，则称为单线程程序。
* 多线程：一个进程如果有多条执行路径，则称为多线程程序。

### 04~07-多线程的实现方式

先学三种实现方式：

* 继承`Thread`类

  ```java
  public class MyThread extends Thread{
      @Override
      public void run() {
          // 自定义一个类，重写run方法，线程开启后，就会执行run方法
          for (int i = 0; i < 100; i++) {
              System.out.println("打印："+i);
          }
      }
  }
  ```

  ```java
  public class MyThreadRunDemo {
      public static void main(String[] args) {
          // 创建两个线程对象
          MyThread t1 = new MyThread();
          MyThread t2 = new MyThread();
          // 用start方法开启线程
          t1.start();
          t2.start();
      }
  }
  
  ```

  看结果可以知道，这两条线程是并发执行的，并且由于cpu上下文切换的随机性，每次运行结果可能都不一样。

  > 为什么要重写run方法？因为线程执行以后，要执行run方法，run方法是用来封装线程需要执行的代码用的。
  >
  > run方法和start方法的区别？通过打印线程名称或者id可以得出，调用run方法是由调用的线程执行的，并没有开启新的方法。而start方法是新开一个线程去执行，开启新线程的方法是由c++实现的，在Java中属于本地方法(native)，源码中可以找到，方法名是start0。

  ![image-20230619221020867](http://www.iocaop.com/images/2023-06/202306192210893.png)

* 实现`Runnable`接口

  ```java
  public class MyRunnableRunDemo {
      public static void main(String[] args) {
          MyRunnable runnable = new MyRunnable();
          // 需要注意的时，runnable中没有start方法，需要将runnable对象作为参数，传递给Thread的构造,来启动线程
          Thread t1 = new Thread(runnable);
          Thread t2 = new Thread(runnable);
          t1.start();
          t2.start();
      }
  }
  ```

  ![image-20230619223019198](http://www.iocaop.com/images/2023-06/202306192230220.png)

* `Callable`和`Future`接口实现

  ```java
  public class MyCallable implements Callable<String> {
  
  
      /**
       * 和run方法一样，是线程执行代码的封装方法
       * 返回值是实现Callable时所指定的泛型，这里是String，意味着线程执行call方法，返回结果也是String类型
       *
       * @return {@link String}
       * @throws Exception 异常
       */
      @Override
      public String call() throws Exception {
          for (int i = 0; i < 100; i++) {
              System.out.println("打印："+i);
          }
          return "call执行完毕";
      }
  }
  
  ```

  ```java
  public class MyCallableRunDemo {
      public static void main(String[] args) throws ExecutionException, InterruptedException {
          // 线程开启后，会调用该对象的call方法，执行封装好的代码
          MyCallable myCallable = new MyCallable();
          // 可以获取call方法的返回结果，同时作为参数传递给Thread的构造
          FutureTask<String> futureTask = new FutureTask<>(myCallable);
          // 创建线程对象
          Thread thread = new Thread(futureTask);
          // 开启线程
          thread.start();
          // 获取线程执行的结果
          String s = futureTask.get();
          System.out.println("线程执行的结果:"+s);
      }
  }
  ```

  为什么创建线程的时候不能直接传递`Callable`实现类的对象呢？因为`Thread`的构造需要的是`Runnable`接口的实现类对象，而`Callable`没有实现`Runnable`接口，`FutureTask`实现了`Runnable`接口：

  ![image-20230619223850027](http://www.iocaop.com/images/2023-06/202306192238074.png)

![image-20230619223903642](http://www.iocaop.com/images/2023-06/202306192239663.png)

执行结果：

![image-20230619224547900](http://www.iocaop.com/images/2023-06/202306192245921.png)

思考一个问题：如果在`start()`方法调用执行使用`FutureTask`的`get()`方法，会发生什么？

没有任何结果，但是`main`方法也没有停止。`get()`方法是获取线程执行的结果，如果线程还没有启动运行，那么`get()`方法会一直等着。

### 08-三种实现方式的对比

![image-20230619225157623](http://www.iocaop.com/images/2023-06/202306192251661.png)

### 09-Thread方法-设置、获取线程名称

获取线程名称：

```java
public class MyThread extends Thread{
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            // 调用Thread中继承过来的方法获取线程名称
            System.out.println(super.getName()+"打印："+i);
        }
    }
}
```

```java
public class MyThreadDemo {
    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        myThread.start();
    }
}
```

![image-20230619225756142](http://www.iocaop.com/images/2023-06/202306192257163.png)

线程是有默认名字的，格式为`Thread-编号`，源码中可以看出：

![image-20230619230023319](http://www.iocaop.com/images/2023-06/202306192300341.png)

![image-20230619230037480](http://www.iocaop.com/images/2023-06/202306192300516.png)

设置线程名称：

方式1：调用set方法

```java
public class MyThreadDemo {
    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        myThread.setName("我的线程1");
        myThread.start();
    }
}
```

方式2：构造方法传入

```java
public class MyThreadDemo {
    public static void main(String[] args) {
        MyThread myThread = new MyThread("我的线程1");
        myThread.start();
    }
}
```

```java
public class MyThread extends Thread{

    public MyThread(String name) {
        super(name);
    }

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            // 调用Thread中继承过来的方法获取线程名称
            System.out.println(super.getName()+"打印："+i);
        }
    }
}
```

### 10-Thread方法-获取当前线程对象

![image-20230619230506472](http://www.iocaop.com/images/2023-06/202306192305501.png)

获取当前线程对象，当前线程是由哪个线程执行，就会返回哪个线程的对象。

### 11-Thread方法-sleep

![image-20230619230646498](http://www.iocaop.com/images/2023-06/202306192306526.png)

让线程休眠，哪条线程执行到了这个方法，就会将哪条线程进行休眠，参数是休眠时间，单位是毫秒。

会抛出异常，处理异常的线程是调用线程(谁调用了`Thread.sleep()`这个异常就是谁处理)。

### 12-线程调度-线程的优先级

多线程的并发：

计算机中的cpu在任一时刻只能执行一条及其指令，每个线程只有获得cpu的使用权才能执行任务，<span style="background-color:pink;">各个线程轮流获得cpu的执行权</span>，分别执行各自的任务。

两种调度模型：

* 分时调度模型：所有线程轮流使用cpu，<span style="background-color:pink;">平均分配</span>每个线程占用cpu的时间片。

* 抢占式调度模型：<span style="background-color:pink;">优先让优先级高的线程使用cpu</span>，优先级相同则随机，这样以来，优先级高的线程，获取cpu的时间片相对多一些。

<span style="background-color:pink;">Java中使用的是抢占式调度模型</span>

Java中可以设置线程的优先级：`Thread`类的源码

![image-20230619231644709](http://www.iocaop.com/images/2023-06/202306192316739.png)

默认优先级是5，最大10，最小1。

线程优先级越高，只能说明他抢到cpu使用权的几率更高，不意味着他先执行。

### 13-Thread方法-守护线程

又叫后台线程。

普通线程执行完毕了，守护线程也会停止运行：`Thread`源码

![image-20230619232351246](http://www.iocaop.com/images/2023-06/202306192323272.png)

守护线程的意义是什么？守护普通线程

比如qq传文件，传到一般，我把整个qq退出了。那传输文件的线程就是守护线程，整个qq退出了，守护线程传文件就没必要存在了。

写个demo，普通线程循环打印10次，守护线程循环打印100次，普通线程打印完10次，守护线程会继续执行吗？

```java
public class MyThread01 extends Thread{
    @Override
    public void run() {
        super.setName("普通线程");
        for (int i = 0; i < 10; i++) {
            System.out.println(super.getName()+"---"+i);
        }
    }
}
```

```java
public class MyThread02 extends Thread{
    @Override
    public void run() {
        super.setName("守护线程");
        for (int i = 0; i < 100; i++) {
            System.out.println(super.getName()+"---"+i);
        }
    }
}

```

```java
public class MyDaemonRunDemo {
    public static void main(String[] args) {
        MyThread01 myThread01 = new MyThread01();
        MyThread02 myThread02 = new MyThread02();
        // 设置为守护线程
        myThread02.setDaemon(true);

        myThread01.start();
        myThread02.start();

    }
}
```

![image-20230619233256813](http://www.iocaop.com/images/2023-06/202306192332837.png)

结果可以看出，当普通线程执行完毕后，守护线程并不会继续执行了。但也不会马上停止，因为他还占用着cpu，要过一会再停止。

## 11-2线程安全问题

### 14-卖票案例实现

多个线程同时操作共享资源，就会有线程安全问题。

需求：某电影院上映国产大片，一共100张票，有3个卖票窗口，编程模拟卖票。

思路：实现`Runnable`接口，run方法卖票，成员变量表示余票。三个窗口线程使用相同的`Runnable`对象，保证100张票是共享的。

```java
public class Ticket implements Runnable{

    private Integer count=100;

    @Override
    public void run() {
        while (true){
            if (count<=0){
                throw new RuntimeException("卖完啦");
            }
            this.count--;
            System.out.println(Thread.currentThread().getName()+"卖出一张票，还剩："+this.count+"张");
        }
    }
}
```

```java
public class MyTicketRunDemo {
    public static void main(String[] args) {
        Ticket ticket = new Ticket();
        Thread t1 = new Thread(ticket);
        Thread t2 = new Thread(ticket);
        Thread t3 = new Thread(ticket);

        t1.setName("窗口1");
        t2.setName("窗口2");
        t3.setName("窗口3");

        t1.start();
        t2.start();
        t3.start();
    }
}

```

运行：

![image-20230619235804690](http://www.iocaop.com/images/2023-06/202306192358722.png)

> 结合我所学的知识，已经看出问题，在抛出异常的if这里，cpu执行时，if并不是一条指令，会被编译成多条指令，有一种可能，当售票到最后一张票(不是最后一张也行，Redis的自增自减是原子操作，java中的i--不是原子操作，<a href='https://blog.csdn.net/qq_39835588/article/details/82933777?spm=1001.2101.3001.6650.17&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-17-82933777-blog-123495656.235%5Ev38%5Epc_relevant_default_base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-17-82933777-blog-123495656.235%5Ev38%5Epc_relevant_default_base&utm_relevant_index=18'>点击跳转</a>，一样会超卖)，当判断指令(jcc指令)刚走完，还没来得及自减，cpu就调度了，执行另一个线程的指令了，此时count会被多个线程自减多次即使他已经小于等于0了(因为判断已经走完了)，导致超卖。

### 15-卖票案例并发问题原因分析

结合生活实际，售票出票需要时间，我们给线程加点延迟，每次出票时间是100毫秒，即每次自减，睡眠100毫秒，看看会怎么样？

```java
public class Ticket implements Runnable{

    private Integer count=100;

    @Override
    public void run() {
        while (true){
            if (count<=0){
                throw new RuntimeException("卖完啦");
            }
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            this.count--;
            System.out.println(Thread.currentThread().getName()+"卖出一张票，还剩："+this.count+"张");
        }
    }
}
```

看结果：出现了负数

![image-20230620002028101](http://www.iocaop.com/images/2023-06/202306200020134.png)

情况1：重复票

线程1执行到打印语句之前是99，切到线程2，又走到打印语句前是98，切到线程3，又走到打印语句前是97，这是线程1、线程2、线程3都走打印语句。打出来三个都是97.重复票。

情况2：超卖，负号票

和我上面14节课说的一样，线程1、线程2、线程3都走到自减之前，cpu调度了，导致超卖。

### 16-同步代码块

我们看看，操作共享数据的代码是哪块：从判断语句就开始了，直到打印语句。

![image-20230620003410812](http://www.iocaop.com/images/2023-06/202306200034844.png)

思考：如果操作共享数据时，只让一条线程操作，等这条数据操作完了，其他线程再操作，是不是就解决了上面的两个问题？

* 为什么出现问题？

  多线程操作共享数据

* 如何解决多线程安全问题？

  基本思想：让程序没有安全问题的环境

* 怎么实现？

  多条语句操作共享数据的代码锁起来，让任意时刻只能有一个线程执行。

同步代码块：

```java
synchronized(任意对象){多条语句操作共享数据的代码}
```

默认情况，这个锁是打开的，只要有一个线程进去执行代码了，锁就会关闭。当线程执行完毕出来了，锁才会自动打开。

锁的好处和弊端：

好处是解决了多线程的数据安全问题。

坏处是影响性能，线程很多，都会访问同步上的锁，耗费资源。

实现：修改run方法，加锁。

```java
    @Override
    public void run() {
        while (true){
            synchronized (this){
                if (count<=0){
                    throw new RuntimeException("卖完啦");
                }
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                this.count--;
                System.out.println(Thread.currentThread().getName()+"卖出一张票，还剩："+this.count+"张");
            }
        }
    }
```

加锁后运行，不会出现重复票和负号票：

![image-20230620004552584](http://www.iocaop.com/images/2023-06/202306200045625.png)

### 17-锁对象的唯一

将上面的卖票案例改写，不使用`Runnable`，而是直接继承`Thread`类：

```java
public class TicketThread extends Thread{
    private Integer count=100;

    @Override
    public void run() {
        while (true){
            synchronized (this){
                if (count<=0){
                    throw new RuntimeException("卖完啦");
                }
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                this.count--;
                System.out.println(Thread.currentThread().getName()+"卖出一张票，还剩："+this.count+"张");
            }
        }
    }
}

```

```java
public class MyTicketRunDemo {
    public static void main(String[] args) {
        Thread t1 = new TicketThread();
        Thread t2 = new TicketThread();
        Thread t3 = new TicketThread();

        t1.setName("窗口1");
        t2.setName("窗口2");
        t3.setName("窗口3");

        t1.start();
        t2.start();
        t3.start();
    }
}
```

运行发现，每张票都是重复票，原因：count不是共享数据，需要加`static`：

```java
    private static Integer count=100;
```

修改后运行发现：出现负号票，原因，锁不是唯一的，使用的是`this`,是线程对象，三个窗口各自有各自的对象，锁不唯一

![image-20230620005621838](http://www.iocaop.com/images/2023-06/202306200056876.png)

将锁改为唯一的：

```java
 synchronized (this.getClass())
```

运行结果正常：

![image-20230620005809893](http://www.iocaop.com/images/2023-06/202306200058926.png)

### 18-同步方法

同步方法：就是把`synchronized`关键字加到方法上。

格式：

```java
修饰符 synchronized 返回值类型 方法名(方法参数){}
```

同步代码块和同步方法的区别：

* 同步代码块是锁住指定的方法，同步方法是锁住方法中所有的代码。
* <span style="background-color:pink;">同步代码块可以指定锁对象，同步方法不能指定锁对象。</span>

同步方法的锁对象是谁？是`this`。

将上面的售票案例，改为窗口1使用同步方法，窗口2使用同步代码块：

```java
/**
 * 同步方法和同步代码块
 *
 * @author 赖卓成
 * @date 2023/06/21
 */
public class MyRunnable implements Runnable {

    public static int count = 100;

    @Override
    public void run() {
        while (true) {
            if ("窗口1".equals(Thread.currentThread().getName())) {
                boolean empty = this.syncMethod();
                if (empty) {
                    break;
                }
            }

            if ("窗口2".equals(Thread.currentThread().getName())) {
                // 同步代码块
                synchronized (new Object()) {
                    if (count <= 0) {
                        break;
                    }
                    try {
                        Thread.sleep(100L);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                    count--;
                    System.out.println(Thread.currentThread().getName() + "卖出一张票，还剩：" + count + "张");
                }
            }
        }
    }

    /**
     * 同步方法
     *
     * @return boolean
     */
    private synchronized boolean syncMethod() {
        if (count <= 0) {
            return true;
        }
        try {
            Thread.sleep(100L);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        count--;
        System.out.println(Thread.currentThread().getName() + "卖出一张票，还剩：" + count + "张");
        return false;
    }
}
```

```java
/**
 * 同步方法和同步代码块
 *
 * @author 赖卓成
 * @date 2023/06/21
 */
public class MyRunnableRunDemo {

    public static void main(String[] args) {
        MyRunnable myRunnable = new MyRunnable();
        Thread t1 = new Thread(myRunnable);
        Thread t2 = new Thread(myRunnable);

        t1.setName("窗口1");
        t2.setName("窗口2");

        t1.start();
        t2.start();
    }

}

```

### 19-Lock

上面两节使用了`synchronized`，同步方法和同步代码块。我们可以理解他加了锁，但是却看不到他在哪里加了锁，哪里释放了锁，为了更清楚地表达如何加锁、释放锁，jdk5以后提供了一个新的锁对象`Lock`。

`Lock`提供了比使用`synchronized`方法和语句可以获得更广泛的锁定操作。

* void lock()：获得锁
* void unlock()：释放锁

`Lock`是接口，不能直接实例化，这里才用它的实现类`ReentrantLock`来实例化。

这里先简单使用一下`ReentrantLock`,改写之前的售票案例：

```java
public class TicketThread extends Thread {
    private static Integer count = 100;
    /**
     * 为了多个线程使用同一把锁，需要将锁定义为静态变量
     */
    private static ReentrantLock lock = new ReentrantLock();
    @Override
    public void run() {

        while (true) {
            lock.lock();
            if (count <= 0) {
                throw new RuntimeException("卖完啦");
            }
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            count--;
            System.out.println(Thread.currentThread().getName() + "卖出一张票，还剩：" + count + "张");
            lock.unlock();
        }

    }
}
```

```java
public class MyTicketRunDemo {
    public static void main(String[] args) {
        Thread t1 = new TicketThread();
        Thread t2 = new TicketThread();
        Thread t3 = new TicketThread();

        t1.setName("窗口1");
        t2.setName("窗口2");
        t3.setName("窗口3");

        t1.start();
        t2.start();
        t3.start();
    }
}

```

运行结果正确：

![image-20230626203832864](http://www.iocaop.com/images/2023-06/202306262038906.png)

### 20-死锁

死锁是指两个或多个线程相互持有对方所需要的资源，导致这些资源处于等待状态，无法继续往前执行。

课程中的例子：

![image-20230626204340032](http://www.iocaop.com/images/2023-06/202306262043066.png)

![image-20230626204356124](http://www.iocaop.com/images/2023-06/202306262043173.png)

![image-20230626204454455](http://www.iocaop.com/images/2023-06/202306262044509.png)

代码实现：

```java
/**
 * 死锁
 *
 * @author lzc
 * @date 2023/06/26
 */
public class DeadLock {

    public static void main(String[] args) {
        // 创建两把锁
        Object lockA = new Object();
        Object lockB = new Object();

        new Thread(()->{
           while (true){
               synchronized (lockA){
                   synchronized (lockB){
                       System.out.println(new Date()+"线程1获取了两把锁");
                   }
               }
           }
        }).start();

        new Thread(()->{
            while (true){
                synchronized (lockB){
                    synchronized (lockA){
                        System.out.println(new Date()+"线程2获取了两把锁");
                    }
                }
            }
        }).start();
    }
}

```

线程1先获取锁A，再获取锁B。线程2先获取锁B，再获取锁A。

有一种情况，就是线程1获取锁A或，cpu切换到线程2，线程2获取了锁B，导致线程1无法获取锁B，而线程2需要的锁A又被线程1获取了。两个线程互相等待，导致死锁。<span style="background-color:pink;">打印了一段时间后，就不再打印了，但是程序没有停止。</span>

![image-20230626205302448](http://www.iocaop.com/images/2023-06/202306262053484.png)

> 如何解决？不要嵌套使用锁就好了。

## 11-3-生产者和消费者

### 21-思路分析

生产者生产出来的东西，给消费者消费。课程中的例子：厨师生产汉堡，放到桌子上，吃货来吃。

![image-20230626212414393](http://www.iocaop.com/images/2023-06/202306262124444.png)

吃货线程和厨师线程需要轮流执行。

厨师：

* 判断桌子上是否有汉堡，有则等待，没有则生产
* 把汉堡放桌上
* 叫醒吃货吃汉堡

吃货：

- 判断桌子上是否有汉堡
- 没有则等待
- 如果有就吃
- 吃完后，桌上没了
- 叫醒等待的厨师继续生产

### 22-代码实现

为了体现生产和消费过程的<span style="background-color:pink;">等待</span>和<span style="background-color:pink;">唤醒</span>，Java在Object类提供了方法：

![image-20230626212704722](http://www.iocaop.com/images/2023-06/202306262127763.png)

```java
/**
 * 厨师线程
 *
 * @author lzc
 * @date 2023/06/26
 */
public class Cooker extends Thread {

    @Override
    public void run() {
        // 死循环
        while (true) {
            // 获取锁
            synchronized (Desk.lock) {
                // 是否生产够了10个
                if (Desk.count <= 0) {
                    break;
                }
                // 桌子上是否有汉堡
                if (Desk.flag) {
                    // 有则等待
                    try {
                        Desk.lock.wait();
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                } else {
                    // 没有则生产,将标志设置为有
                    Desk.flag = true;
                    // 生产者这里不处理count了,在消费者处理一次即可。
                    System.out.println("厨师已经生产了第" + (1001 - Desk.count) + "个汉堡！");
                    // 通知吃货来吃,这里我们只开启了一个吃货和一个厨师，所以不使用notifyAll()
                    Desk.lock.notify();
                }
            }
        }

    }
}
```

```java
/**
 * 吃货线程
 *
 * @author lzc
 * @date 2023/06/26
 */
public class Foodie extends Thread {
    @Override
    public void run() {
        // 死循环
        while (true) {
            // 获取锁
            synchronized (Desk.lock) {
                // 吃够了10个没有
                if (Desk.count <= 0) {
                    break;
                }
                // 桌子上是否有汉堡
                if (Desk.flag) {
                    // 有则吃
                    System.out.println("吃货吃完了第" + (1001 - Desk.count) + "个汉堡");
                    // 数量减1
                    Desk.count--;
                    // 修改标记
                    Desk.flag = false;
                    // 通知厨师生产汉堡
                    Desk.lock.notify();
                } else {
                    //没有汉堡则等待,需要注意的是，这里调用wait方法的锁，需要生产者和消费者是同一把锁，也就是同一个对象去调用
                    try {
                        Desk.lock.wait();
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                }
            }

        }
    }
}

```

```java
/**
 * 桌子
 *
 * @author lzc
 * @date 2023/06/26
 */
public class Desk {

    /**
     * 汉堡数量
     */
    public static int count = 1000;

    /**
     * 锁
     */
    public static Object lock = new Object();

    /**
     * 标志、桌子上是否有汉堡
     */
    public static boolean flag = false;

    public static void main(String[] args) {
        Cooker cooker = new Cooker();
        Foodie foodie = new Foodie();
        cooker.start();
        foodie.start();
    }
}
```

运行结果：无论设置数量为多少，都是交替执行。

![image-20230626221528443](http://www.iocaop.com/images/2023-06/202306262215475.png)

> 需要注意，厨师生产完或吃货吃完，都需要调用使用锁对象调用`notify()`方法来通知其他线程。

### 23-代码改写

上面代码用的是简单的方式，我们改写一下，面向对象。

```java
/**
 * 桌子
 *
 * @author lzc
 * @date 2023/06/26
 */
@Data
@AllArgsConstructor
public class Desk {

    /**
     * 汉堡数量
     */
    private   int count = 1000;

    /**
     * 锁
     */
    private  Object lock = new Object();

    /**
     * 标志、桌子上是否有汉堡
     */
    private  boolean flag = false;


}

```

```java
/**
 * 厨师线程
 *
 * @author lzc
 * @date 2023/06/26
 */
@AllArgsConstructor
public class Cooker extends Thread {

    private Desk desk;

    @Override
    public void run() {
        // 死循环
        while (true) {
            // 获取锁
            synchronized (this.desk.getLock()) {
                // 是否生产够了10个
                if (this.desk.getCount()<= 0) {
                    break;
                }
                // 桌子上是否有汉堡
                if (this.desk.isFlag()) {
                    // 有则等待
                    try {
                       this.desk.getLock().wait();
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                } else {
                    // 没有则生产,将标志设置为有
                    this.desk.setFlag(true);
                    // 生产者这里不处理count了,在消费者处理一次即可。
                    System.out.println("厨师已经生产了第" + (1001 - this.desk.getCount()) + "个汉堡！");
                    // 通知吃货来吃,这里我们只开启了一个吃货和一个厨师，所以不使用notifyAll()
                    this.desk.getLock().notify();
                }
            }
        }

    }
}
```

```java
/**
 * 吃货线程
 *
 * @author lzc
 * @date 2023/06/26
 */
@AllArgsConstructor
public class Foodie extends Thread {

    private Desk desk;

    @Override
    public void run() {
        // 死循环
        while (true) {
            // 获取锁
            synchronized (this.desk.getLock()) {
                // 吃够了10个没有
                if (this.desk.getCount() <= 0) {
                    break;
                }
                // 桌子上是否有汉堡
                if (this.desk.isFlag()) {
                    // 有则吃
                    System.out.println("吃货吃完了第" + (1001 - this.desk.getCount()) + "个汉堡");
                    // 数量减1
                    this.desk.setCount(this.desk.getCount()-1);
                    // 修改标记
                    this.desk.setFlag(false);
                    // 通知厨师生产汉堡
                    this.desk.getLock().notify();
                } else {
                    //没有汉堡则等待,需要注意的是，这里调用wait方法的锁，需要生产者和消费者是同一把锁，也就是同一个对象去调用
                    try {
                        this.desk.getLock().wait();
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                }
            }

        }
    }
}
```

```java
public class Demo {

    public static void main(String[] args) {
        Desk desk = new Desk(1000, new Object(), false);
        Cooker cooker = new Cooker(desk);
        Foodie foodie = new Foodie(desk);
        cooker.start();
        foodie.start();
    }
}
```

### 24-阻塞队列-基本使用

阻塞队列实现等待唤醒机制。

还是上面的生产者消费者案例，只不过消费者消费时，是从阻塞队列中拿，如果有，就拿一个来消费，没有就等待

![image-20230627014210720](http://www.iocaop.com/images/2023-06/202306270142761.png)

阻塞队列的继承结构：

![image-20230627014229885](http://www.iocaop.com/images/2023-06/202306270142926.png)

常见的`BlockingQueue`:

* ArrayBlockingQueue:底层是数组，有界

  ![image-20230627014558401](http://www.iocaop.com/images/2023-06/202306270145439.png)

  ```java
  /**
   * 阻塞队列demo01
   *
   * @author lzc
   * @date 2023/06/27
   */
  public class BlockingQueueDemo01 {
  
      public static void main(String[] args) {
          ArrayBlockingQueue<String> arrayBlockingQueue = new ArrayBlockingQueue<>(1);
  
          try {
              arrayBlockingQueue.put("汉堡包");
              System.out.println("arrayBlockingQueue.take() = " + arrayBlockingQueue.take());
              // 阻塞队列中只有一个元素，如果取两次，就会一直等待着，所以不会走到程序结束的代码
              System.out.println("arrayBlockingQueue.take() = " + arrayBlockingQueue.take());
              System.out.println("程序结束了");
          } catch (InterruptedException e) {
              throw new RuntimeException(e);
          }
  
      }
  }
  
  ```

  一直等待，程序不会停止：

  ![image-20230627014917585](http://www.iocaop.com/images/2023-06/202306270149614.png)

* LinkedBlockingQueue：底层是链表，无界。但不是真正的无界，是int的最大值。

### 25-阻塞队列-等待唤醒机制

使用阻塞队列实现生产者消费者案例：

```java
@AllArgsConstructor
public class Cooker extends Thread{

    private ArrayBlockingQueue<String> blockingQueue;

    @Override
    public void run() {
        while (true){
            try {
                this.blockingQueue.put("汉堡包");
                System.out.println("厨师做好了一个汉堡包！");
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
```

```java
@AllArgsConstructor
public class Foodie extends Thread{

    private ArrayBlockingQueue<String> blockingQueue;

    @Override
    public void run() {
        while (true){
            try {
                String take = this.blockingQueue.take();
                System.out.println("吃货吃掉了一个"+take);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
```

```java
public class Demo {

    public static void main(String[] args) {
        ArrayBlockingQueue<String> arrayBlockingQueue = new ArrayBlockingQueue<>(1);

        Cooker cooker = new Cooker(arrayBlockingQueue);
        Foodie foodie = new Foodie(arrayBlockingQueue);

        cooker.start();
        foodie.start();


    }
}
```

运行结果：

![image-20230627020107158](http://www.iocaop.com/images/2023-06/202306270201192.png)

出乎意料，队列容量只有1，为什么会出现重复吃掉两个汉堡或者重复做了两个汉堡？

查看源码：

![image-20230627020257271](http://www.iocaop.com/images/2023-06/202306270202321.png)

![image-20230627020313206](http://www.iocaop.com/images/2023-06/202306270203246.png)

可以看出来，加锁的范围是`put()`和`take()`，我们手写的打印语句并不在加锁范围内。

简单说，就是吃货线程刚吃完一个，打印了一行，cpu切换到厨师线程，做好一个汉堡后，因为打印语句不在锁范围内，cpu可以切换到吃货线程，这时候队列已经有汉堡了，吃货又吃，打印了一行，导致连续打印两行，然后又切回到厨师线程，打印做好了。

gpt的回答：

![image-20230627022239986](http://www.iocaop.com/images/2023-06/202306270222026.png)

![image-20230627022248958](http://www.iocaop.com/images/2023-06/202306270222998.png)

## 11-4线程池和volatile

### 01-线程状态

![image-20230627110507194](http://www.iocaop.com/images/2023-06/image-20230627110507194.png)

在虚拟机中，线程有六种状态：

* 新建状态(NEW)：创建线程对象
* 就绪状态(RUNNABLE)：线程对象调用`start()`方法，这时候需要等待cpu时间片才会运行，虚拟机中没有定义运行状态。
* 阻塞状态(BLOCKED)：无法获得锁对象
* 等待状态(WAITING)：遇到`wait()`方法
* 计时等待(TIMED_WAITING)：遇到`sleep()`方法
* 结束状态(TERMINATED)：全部代码执行完毕

如何验证这六种状态？在`Thread`类中有枚举成员：

![image-20230627112044870](http://www.iocaop.com/images/2023-06/image-20230627112044870.png)

![image-20230627112114551](http://www.iocaop.com/images/2023-06/image-20230627112114551.png)

### 02-线程池-基本原理

以前写多线程的弊端：

* 用到线程时就需要创建
* 用完之后线程消失

解决方案：

* 创建线程池，用于存放线程，刚开始是空的
* 当有任务需要线程执行，则创建线程放到线程池，使用时取(看是否有空闲的线程，有则取，没有则创建新的)，使用完后，将线程归还给线程池。

### 03-Executors默认线程池

* 创建线程池：`Executors`中的静态方法

* 有任务需要执行，创建线程对象，执行完，线程对象归还给线程池。：`submit()`方法，<span style="background-color:pink;">会自动创建线程对象，任务执行完会自动归还给线程池。</span>

* 所有任务执行完，关闭线程池：`shutdown()`方法。

看API，学习两个方法：

![image-20230627113334648](http://www.iocaop.com/images/2023-06/image-20230627113334648.png)

写个demo：

```java
public class MyThreadPoolDemo01 {

    public static void main(String[] args) {
        // Executors帮助我们创建线程池对象，默认是空的，可以容纳int的最大值个线程
        ExecutorService executorService = Executors.newCachedThreadPool();
        // 返回值ExecutorService 可以帮助我们控制线程池

        executorService.submit(()->{
            System.out.println(Thread.currentThread().getName()+"执行了");
        });

        executorService.submit(()->{
            System.out.println(Thread.currentThread().getName()+"执行了");
        });

        // 关闭线程池
        executorService.shutdown();

    }

}
```

执行结果：

![image-20230627114302297](http://www.iocaop.com/images/2023-06/image-20230627114302297.png)

当修改代码：

![image-20230627114405925](http://www.iocaop.com/images/2023-06/image-20230627114405925.png)

看到，只有一个线程了。

第一种结果是因为执行第一个任务时，还没来及归还线程给线程池，又执行第二个任务，所以会创建新的线程来执行。

第二种结果是主线程睡眠了2秒，线程池的第一个任务已经执行完了，将线程归还给了线程池，执行第二个任务时从线程池取了之前那个线程来执行。

### 05-Executors创建指定上限的线程池

```java
/**
 * 指定上限的线程池
 *
 * @author 赖卓成
 * @date 2023/06/27
 */
public class MyThreadPoolDemo02 {

    public static void main(String[] args) {

        // 指定最大10个线程,而不是初始值
        ExecutorService executorService = Executors.newFixedThreadPool(10);

        executorService.submit(()->{
            System.out.println(Thread.currentThread().getName()+"执行了");
        });

        executorService.submit(()->{
            System.out.println(Thread.currentThread().getName()+"执行了");
        });

        // 关闭线程池
        executorService.shutdown();

    }

}
```

![image-20230627152458782](http://www.iocaop.com/images/2023-06/image-20230627152458782.png)

> 需要注意的是，我们传入的参数是指定线程池中的最大线程数，而不是初始线程数。

到这里，好像和上面的默认线程池没什么区别，但是，通过debug或者强转可以知道，这个线程池最大线程数被我们设置成10了，并不是初始线程数是10。

![image-20230627152815624](http://www.iocaop.com/images/2023-06/image-20230627152815624.png)

![image-20230627152939649](http://www.iocaop.com/images/2023-06/image-20230627152939649.png)

### 06-ThreadPoolExecutor

之前都是使用了默认的创建线程池的方法，那现在想要自定义创建线程池，怎么办？

先看看之前的方法的源码：

![image-20230627154039401](http://www.iocaop.com/images/2023-06/image-20230627154039401.png)

![image-20230627154053919](http://www.iocaop.com/images/2023-06/image-20230627154053919.png)

发现，都是创建了`ThreadPoolExecutor`

那么我们创建自定义线程池，也是创建这个对象。看一下API，构造方法：

![image-20230627154620093](http://www.iocaop.com/images/2023-06/image-20230627154620093.png)

![image-20230627160644855](http://www.iocaop.com/images/2023-06/image-20230627160644855.png)

* `corePoolSize`：核心线程数
* `maximumPoolSize`：最大线程数
* `keepAliveTime`:空闲线程的最大存活时间
* `unit`：空闲线程的最大存活时间的单位
* `workQueue`：任务队列
* `threadFactory`：创建线程的方式
* `handler`:拒绝策略

```java
/**
 * 自定义线程池
 *
 * @author 赖卓成
 * @date 2023/06/27
 */
public class MyThreadPoolDemo03 {

    public static void main(String[] args) {
        // 自定义线程池
        ThreadPoolExecutor poolExecutor = new ThreadPoolExecutor(2, 5, 10, TimeUnit.SECONDS,
            new ArrayBlockingQueue<>(3),
            Executors.defaultThreadFactory(), new AbortPolicy());

        poolExecutor.submit(() -> {
            System.out.println(Thread.currentThread().getName() + "执行了");
        });

        poolExecutor.submit(() -> {
            System.out.println(Thread.currentThread().getName() + "执行了");
        });

        poolExecutor.shutdown();


    }

}
```

### 06-自定义线程池参数详解

任务队列：按照上面的传参，核心线程数为2，最大线程数为5。那现在我有10个任务怎么办？多出的5个任务，放到任务队列中，等有空闲线程了，再从队列获取任务并执行。

创建线程工厂：按默认的方式创建线程对象。

拒绝策略：

* 什么时候拒绝任务

  ![image-20230627171421524](http://www.iocaop.com/images/2023-06/image-20230627171421524.png)

  当提交的任务大于(线程池最大线程数+任务队列容量)时，就会拒绝。

* 如何拒绝

  四种拒绝策略：

  ![image-20230627171853637](http://www.iocaop.com/images/2023-06/image-20230627171853637.png)

  * `AbortPolicy`：也是默认策略，丢弃任务，抛出异常`RejectedExecutionException`
  * `DiscardPolicy`：不推荐，丢弃任务，不抛异常。
  * `DiscardOldestPolicy`:丢弃等待队列中等待最久的任务，并把当前任务加入队列。
  * `CallerRunsPolicy`：调用`run()`方法，绕过线程池，直接执行。

试一下触发拒绝策略：

```java
/**
 * 触发拒绝策略
 *
 * @author 赖卓成
 * @date 2023/06/27
 */
public class MyThreadPoolDemo04 {

    public static void main(String[] args) {

        ThreadPoolExecutor poolExecutor = new ThreadPoolExecutor(2, 5, 10, TimeUnit.SECONDS,
            new ArrayBlockingQueue<>(10),
            Executors.defaultThreadFactory(), new AbortPolicy());

        for (int i = 0; i < 16; i++) {
            poolExecutor.submit(()->{
                System.out.println(Thread.currentThread().getName()+"执行了");
            });
        }
    }
}

```

![image-20230627172742705](http://www.iocaop.com/images/2023-06/image-20230627172742705.png)

最大线程数+阻塞队列容量为15，我们提交16个任务，导致抛出异常。

### 07-非默认任务拒绝策略

试试其他几种拒绝策略：

微调一下：

```java
/**
 * 触发拒绝策略
 *
 * @author 赖卓成
 * @date 2023/06/27
 */
public class MyThreadPoolDemo04 {

    public static void main(String[] args) {

        ThreadPoolExecutor poolExecutor = new ThreadPoolExecutor(1, 2, 10, TimeUnit.SECONDS,
            new ArrayBlockingQueue<>(3),
            Executors.defaultThreadFactory(), new AbortPolicy());

        for (int i = 0; i < 6; i++) {
            int finalI = i;
            poolExecutor.submit(()->{
                System.out.println(Thread.currentThread().getName()+"执行了---"+ finalI);
            });
        }
        poolExecutor.shutdown();
    }
}
```

分别测试不同的策略：

`DiscardPolicy`：丢弃任务，不抛异常。

![image-20230627173643896](http://www.iocaop.com/images/2023-06/image-20230627173643896.png)

看出来，丢弃了一个任务，没有打印5

`DiscardOldestPolicy`：丢弃等待时间最久的任务，将当前任务添加到队列。

![image-20230627173900449](http://www.iocaop.com/images/2023-06/image-20230627173900449.png)

这里需要画图理解：

![线程池.drawio](http://www.iocaop.com/images/2023-06/202306272223806.png)



> 需要搞清楚的是：
>
> * 什么时候创建核心线程：
>
>   当你创建一个线程池时，初始时会创建一定数量的核心线程。这些核心线程会一直存在，即使它们当前没有执行任务，以保持线程池的最小线程数。
>
> * 什么时候创建非核心线程：
>
>   在需要执行任务时，线程池首先尝试将任务分配给核心线程来执行。只有当任务队列已满时，才会创建额外的线程（非核心线程）来执行任务。当任务队列中的任务得到处理后，非核心线程会被销毁，以保持线程池的大小在核心线程数范围内。
>
> * 什么时候将任务放到队列：
>
>   核心线程数都被占用了，放到任务队列。
>
> * 什么时候触发拒绝策略：
>
>   线程池满了，任务队列满了的时候。
>
> * 什么时候丢弃任务：
>
>   触发拒绝策略时根据策略丢弃。

细节：

> 根据这个拒绝策略，达到最大线程池，再次执行该任务的提交流程：
> 核心线程->队列->非核心线程，
> （但是这里的核心线程不管是不是执行完任务1，都会放到队列中，因为在任务1的时候，核心线程已经作为该核心线程的第一个任务firstTask，
> 也就是核心线程（这里只有一个核心）在首个任务之后，之后的任务都会先放到队列，
> 然后由线程（两个线程谁拿到了谁就去执行，但是根据执行结果来看，说明两个线程的第一个任务都没执行结束）去队列拿任务。
