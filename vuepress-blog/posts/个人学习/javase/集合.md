---
title: java基础-集合
date: 2023-05-06
category:
  - JavaSE
---

## 9-1-Collection

### 01-集合与数组对比

* 数组的长度是不可变的，集合的长度是可变的。
* 数组可以存基本数据类型和引用数据类型。集合只能存引用数据类型，如果集合要存基本数据类型，需要存对应的<span style="background-color:pink;">包装类</span>。

### 02-集合体系结构

![image-20230506004215802](http://www.iocaop.com/images/2023-05/image-20230506004215802.png)

### 03-Collection常见成员方法

Collection概述和使用：

* 是单列集合的顶层接口，他表示一组对象，这些对象也称为`Collection`的元素
* JDK不提供此接口的任何实现。提供更具体的子接口(如`List`、`Set`)的实现。

创建Collection集合的对象

* 多态的方式
* 具体的实现类`ArrayList`

常用成员方法：

![image-20230506004713015](http://www.iocaop.com/images/2023-05/image-20230506004713015.png)

除了removeif方法，其他方法都比较常规。

```java
public class CollectionDemo01 {
    public static void main(String[] args) {
        Collection<String> list = new ArrayList<>();
        list.add("aaa");
        list.add("bbb");
        list.add("ccc");
        list.add("aaaa");
        list.removeIf(s->s.length()==3);
        System.out.println("list = " + list);
    }
}
```

![image-20230506010046853](http://www.iocaop.com/images/2023-05/image-20230506010046853.png)

参数是一个函数式接口，可以使用lamda表达式，会遍历整个集合，进行满足条件的就会进行删除。

解释：传入`Predicate`实现类，该方法会获取集合的迭代器，遍历集合元素，并调用实现类的`test`方法，逐个进行判断，如果实现类的`test`方法结果为`true`，则删除元素。

### 04-迭代器的基本使用

Collection接口中有获取迭代器对象的抽象方法：是由实现类提供具体实现。

![image-20230508101824877](http://www.iocaop.com/images/2023-05/image-20230508101824877.png)

作用：返回集合中的迭代器对象，该迭代器对象默认指向当前集合的0索引。

迭代器`Iterator`中的方法：

![image-20230508102050231](http://www.iocaop.com/images/2023-05/image-20230508102050231.png)

使用迭代器遍历集合：

```java
public class CollectionDemo03 {
    public static void main(String[] args) {
        Collection<String> list = new ArrayList<>();
        list.add("a");
        list.add("b");
        list.add("c");
        list.add("d");
        // 1 获取迭代器对象。迭代器对象一旦创建出来，默认指向0索引
        Iterator<String> iterator = list.iterator();


        // 2 利用迭代器中的方法来遍历集合
        // 迭代器当前指向位置是否有元素可以取出
        boolean b = iterator.hasNext();
        System.out.println(b);
        // next()方法做了两件事情，1取出当前位置元素 2将迭代器往后移动一个索引的位置
        System.out.println("iterator.next() = " + iterator.next());

        System.out.println("iterator.next() = " + iterator.next());
        System.out.println("iterator.next() = " + iterator.next());
        System.out.println("iterator.next() = " + iterator.next());
        System.out.println("iterator.next() = " + iterator.next());

    }
}
```

会报错：

![image-20230508102911014](http://www.iocaop.com/images/2023-05/image-20230508102911014.png)

> 为什么会报错？因为只有4个元素，却调用了5次next()方法，第五次调用时，迭代器指向的位置已经超出了集合索引范围。所以报错了

为了防止报错，在遍历时需要调用`hasNext()`方法，判断迭代器当前指向位置是否有元素可以取出。

```java
public class CollectionDemo03 {
    public static void main(String[] args) {
        Collection<String> list = new ArrayList<>();
        list.add("a");
        list.add("b");
        list.add("c");
        list.add("d");
        // 1 获取迭代器对象。迭代器对象一旦创建出来，默认指向0索引
        Iterator<String> iterator = list.iterator();
        
        // 2 利用迭代器中的方法来遍历集合
        // 迭代器当前指向位置是否有元素可以取出
        boolean b = iterator.hasNext();
        System.out.println(b);
        // next()方法做了两件事情，1取出当前位置元素 2将迭代器往后移动一个索引的位置
        while (iterator.hasNext()){
            System.out.println("iterator.next() = " + iterator.next());
        }
    }
}
```

### 05-迭代器原理

![image-20230508103621647](http://www.iocaop.com/images/2023-05/image-20230508103621647.png)

当迭代器指向最后一个元素时，`hasNext()`方法返回是false。原理个锤子。

### 06-迭代器的删除方法

先写个删除方法：删除集合中字符串为“b”的元素

```java
public class CollectionDemo04 {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("a");
        list.add("b");
        list.add("b");
        list.add("c");
        list.add("d");

        for (int i=0;i<list.size();i++){
            if ("b".equals(list.get(i))){
                list.remove(i);
            }
        }
        System.out.println("list = " + list);
    }
}
```

![image-20230508104225096](http://www.iocaop.com/images/2023-05/image-20230508104225096.png)

可以看到，有个元素明明是"b"却没有被删除，当我们换一下元素位置为：abcbd时(重复元素不连续)又能删除了：

![image-20230508104351060](http://www.iocaop.com/images/2023-05/image-20230508104351060.png)

为什么？

java中的List集合是动态的，当删除一个元素后，长度会自动减1，如图，删除索引1后，长度减1，索引又移动到2了，导致漏了一个元素没有被遍历到。

![image-20230508104652528](http://www.iocaop.com/images/2023-05/image-20230508104652528.png)

![image-20230508104712196](http://www.iocaop.com/images/2023-05/image-20230508104712196.png)

如何解决？

当成功删除后，索引往前移一个位置。

![image-20230508105037290](http://www.iocaop.com/images/2023-05/image-20230508105037290.png)

如果使用迭代器，就不会存在这个问题，迭代器的删除方法，是指向谁就删除谁：

```java
public class CollectionDemo05 {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("a");
        list.add("b");
        list.add("b");
        list.add("c");
        list.add("d");
        Iterator<String> iterator = list.iterator();
        while (iterator.hasNext()){
            String next = iterator.next();
            if ("b".equals(next)){
                // 指向谁就删除谁
                iterator.remove();
            }
        }
        System.out.println("list = " + list);
    }
}
```

gpt的解释：

![image-20230508110950667](http://www.iocaop.com/images/2023-05/image-20230508110950667.png)

迭代器能维护集合状态：

![image-20230508111037732](http://www.iocaop.com/images/2023-05/image-20230508111037732.png)

### 07-增强for

作用：简化<span style="background-color:pink;">数组</span>和<span style="background-color:pink;">Collection集合</span>的遍历

* jdk5以后出现的，内部是一个`Iterator`迭代器
* 实现`Iterable`接口的类才可以使用迭代器和增强for

单列集合顶层`Collection`实现了`Iterable`接口，而双列集合`Map`没有实现该接口。

![image-20230508205244919](http://www.iocaop.com/images/2023-05/image-20230508205244919.png)

![image-20230508205337288](http://www.iocaop.com/images/2023-05/image-20230508205337288.png)

可以得出结论：单列集合都可以使用增强for，而双列集合不行。

格式：

```java
for(元素数据类型 变量名:数组或Collection集合){
// 在此处使用变量即可，该变量就是元素
}
```

举例：

```java
public class CollectionDemo06 {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("a");
        list.add("b");
        list.add("b");
        list.add("c");
        list.add("d");
        // 1.数据类型一定是集合或数组中元素的类型
        // 2.s仅仅是一个变量名而已，在循环的过程中，依次表示集合或数组中的每一个元素
        // 3.list就是要遍历的集合或者数组
        for (String s : list) {
            System.out.println("s = " + s);
        }
    }
}
```

### 08-增强for注意点

```java
public class CollectionDemo07 {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("a");
        list.add("b");
        list.add("b");
        list.add("c");
        list.add("d");
        for (String s : list) {
            s="q";
            System.out.println("s = " + s);
        }
        System.out.println("list = " + list);
    }
}
```

运行结果：

![image-20230508210144493](http://www.iocaop.com/images/2023-05/image-20230508210144493.png)

<span style="background-color:pink;">在增强for中修改变量的值，不会影响集合中的元素</span>

![image-20230508210231708](http://www.iocaop.com/images/2023-05/image-20230508210231708.png)

目前为止学习了三种遍历方式：

* 如果需要操作索引，使用普通for
* 如果再遍历过程中需要删除元素，使用迭代器
* 仅仅只想遍历，使用增强for

## 9-2-List

### 10-List的特点

单列集合分为`List`和`Set`，都实现了`Collection`接口。List又分为`ArrayLis`t和`LinkedList`。

`List`集合特点：

* 有序：存储和取出的元素顺序一致
* 有索引：可以通过索引操作元素
* 可重复：存储的元素可以重复

### 11-List特有方法

![image-20230508211145627](http://www.iocaop.com/images/2023-05/image-20230508211145627.png)

### 12-栈和队列

**栈**

因为只有一端开口，<span style="background-color:pink;">后进先出</span>。

![image-20230508211633942](http://www.iocaop.com/images/2023-05/image-20230508211633942.png)

**队列**

两端口，先进先出。

![image-20230508211851422](http://www.iocaop.com/images/2023-05/image-20230508211851422.png)