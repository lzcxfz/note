---
title: java基础-集合
date: 2023-05-06
category:
  - JavaSE
---

## 9-1-Collection

### 01-集合与数组对比

* 数组的长度是不可变的，集合的长度是可变的。
* 数组可以存基本数据类型和引用数据类型。集合只能存引用数据类型，如果集合要存基本数据类型，需要存对应的<span style="background-color:pink;">包装类</span>。

### 02-集合体系结构

![image-20230506004215802](http://www.iocaop.com/images/2023-05/image-20230506004215802.png)

### 03-Collection常见成员方法

Collection概述和使用：

* 是单列集合的顶层接口，他表示一组对象，这些对象也称为`Collection`的元素
* JDK不提供此接口的任何实现。提供更具体的子接口(如`List`、`Set`)的实现。

创建Collection集合的对象

* 多态的方式
* 具体的实现类`ArrayList`

常用成员方法：

![image-20230506004713015](http://www.iocaop.com/images/2023-05/image-20230506004713015.png)

除了removeif方法，其他方法都比较常规。

```java
public class CollectionDemo01 {
    public static void main(String[] args) {
        Collection<String> list = new ArrayList<>();
        list.add("aaa");
        list.add("bbb");
        list.add("ccc");
        list.add("aaaa");
        list.removeIf(s->s.length()==3);
        System.out.println("list = " + list);
    }
}
```

![image-20230506010046853](http://www.iocaop.com/images/2023-05/image-20230506010046853.png)

参数是一个函数式接口，可以使用lamda表达式，会遍历整个集合，进行满足条件的就会进行删除。

解释：传入`Predicate`实现类，该方法会获取集合的迭代器，遍历集合元素，并调用实现类的`test`方法，逐个进行判断，如果实现类的`test`方法结果为`true`，则删除元素。

### 04-迭代器的基本使用

Collection接口中有获取迭代器对象的抽象方法：是由实现类提供具体实现。

![image-20230508101824877](http://www.iocaop.com/images/2023-05/image-20230508101824877.png)

作用：返回集合中的迭代器对象，该迭代器对象默认指向当前集合的0索引。

迭代器`Iterator`中的方法：

![image-20230508102050231](http://www.iocaop.com/images/2023-05/image-20230508102050231.png)

使用迭代器遍历集合：

```java
public class CollectionDemo03 {
    public static void main(String[] args) {
        Collection<String> list = new ArrayList<>();
        list.add("a");
        list.add("b");
        list.add("c");
        list.add("d");
        // 1 获取迭代器对象。迭代器对象一旦创建出来，默认指向0索引
        Iterator<String> iterator = list.iterator();


        // 2 利用迭代器中的方法来遍历集合
        // 迭代器当前指向位置是否有元素可以取出
        boolean b = iterator.hasNext();
        System.out.println(b);
        // next()方法做了两件事情，1取出当前位置元素 2将迭代器往后移动一个索引的位置
        System.out.println("iterator.next() = " + iterator.next());

        System.out.println("iterator.next() = " + iterator.next());
        System.out.println("iterator.next() = " + iterator.next());
        System.out.println("iterator.next() = " + iterator.next());
        System.out.println("iterator.next() = " + iterator.next());

    }
}
```

会报错：

![image-20230508102911014](http://www.iocaop.com/images/2023-05/image-20230508102911014.png)

> 为什么会报错？因为只有4个元素，却调用了5次next()方法，第五次调用时，迭代器指向的位置已经超出了集合索引范围。所以报错了

为了防止报错，在遍历时需要调用`hasNext()`方法，判断迭代器当前指向位置是否有元素可以取出。

```java
public class CollectionDemo03 {
    public static void main(String[] args) {
        Collection<String> list = new ArrayList<>();
        list.add("a");
        list.add("b");
        list.add("c");
        list.add("d");
        // 1 获取迭代器对象。迭代器对象一旦创建出来，默认指向0索引
        Iterator<String> iterator = list.iterator();
        
        // 2 利用迭代器中的方法来遍历集合
        // 迭代器当前指向位置是否有元素可以取出
        boolean b = iterator.hasNext();
        System.out.println(b);
        // next()方法做了两件事情，1取出当前位置元素 2将迭代器往后移动一个索引的位置
        while (iterator.hasNext()){
            System.out.println("iterator.next() = " + iterator.next());
        }
    }
}
```

### 05-迭代器原理

![image-20230508103621647](http://www.iocaop.com/images/2023-05/image-20230508103621647.png)

当迭代器指向最后一个元素时，`hasNext()`方法返回是false。原理个锤子。

### 06-迭代器的删除方法

先写个删除方法：删除集合中字符串为“b”的元素

```java
public class CollectionDemo04 {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("a");
        list.add("b");
        list.add("b");
        list.add("c");
        list.add("d");

        for (int i=0;i<list.size();i++){
            if ("b".equals(list.get(i))){
                list.remove(i);
            }
        }
        System.out.println("list = " + list);
    }
}
```

![image-20230508104225096](http://www.iocaop.com/images/2023-05/image-20230508104225096.png)

可以看到，有个元素明明是"b"却没有被删除，当我们换一下元素位置为：abcbd时(重复元素不连续)又能删除了：

![image-20230508104351060](http://www.iocaop.com/images/2023-05/image-20230508104351060.png)

为什么？

java中的List集合是动态的，当删除一个元素后，长度会自动减1，如图，删除索引1后，长度减1，索引又移动到2了，导致漏了一个元素没有被遍历到。

![image-20230508104652528](http://www.iocaop.com/images/2023-05/image-20230508104652528.png)

![image-20230508104712196](http://www.iocaop.com/images/2023-05/image-20230508104712196.png)

如何解决？

当成功删除后，索引往前移一个位置。

![image-20230508105037290](http://www.iocaop.com/images/2023-05/image-20230508105037290.png)

如果使用迭代器，就不会存在这个问题，迭代器的删除方法，是指向谁就删除谁：

```java
public class CollectionDemo05 {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("a");
        list.add("b");
        list.add("b");
        list.add("c");
        list.add("d");
        Iterator<String> iterator = list.iterator();
        while (iterator.hasNext()){
            String next = iterator.next();
            if ("b".equals(next)){
                // 指向谁就删除谁
                iterator.remove();
            }
        }
        System.out.println("list = " + list);
    }
}
```

gpt的解释：

![image-20230508110950667](http://www.iocaop.com/images/2023-05/image-20230508110950667.png)

迭代器能维护集合状态：

![image-20230508111037732](http://www.iocaop.com/images/2023-05/image-20230508111037732.png)

### 07-增强for

作用：简化<span style="background-color:pink;">数组</span>和<span style="background-color:pink;">Collection集合</span>的遍历

* jdk5以后出现的，内部是一个`Iterator`迭代器
* 实现`Iterable`接口的类才可以使用迭代器和增强for

单列集合顶层`Collection`实现了`Iterable`接口，而双列集合`Map`没有实现该接口。

![image-20230508205244919](http://www.iocaop.com/images/2023-05/image-20230508205244919.png)

![image-20230508205337288](http://www.iocaop.com/images/2023-05/image-20230508205337288.png)

可以得出结论：单列集合都可以使用增强for，而双列集合不行。

格式：

```java
for(元素数据类型 变量名:数组或Collection集合){
// 在此处使用变量即可，该变量就是元素
}
```

举例：

```java
public class CollectionDemo06 {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("a");
        list.add("b");
        list.add("b");
        list.add("c");
        list.add("d");
        // 1.数据类型一定是集合或数组中元素的类型
        // 2.s仅仅是一个变量名而已，在循环的过程中，依次表示集合或数组中的每一个元素
        // 3.list就是要遍历的集合或者数组
        for (String s : list) {
            System.out.println("s = " + s);
        }
    }
}
```

### 08-增强for注意点

```java
public class CollectionDemo07 {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("a");
        list.add("b");
        list.add("b");
        list.add("c");
        list.add("d");
        for (String s : list) {
            s="q";
            System.out.println("s = " + s);
        }
        System.out.println("list = " + list);
    }
}
```

运行结果：

![image-20230508210144493](http://www.iocaop.com/images/2023-05/image-20230508210144493.png)

<span style="background-color:pink;">在增强for中修改变量的值，不会影响集合中的元素</span>

![image-20230508210231708](http://www.iocaop.com/images/2023-05/image-20230508210231708.png)

目前为止学习了三种遍历方式：

* 如果需要操作索引，使用普通for
* 如果再遍历过程中需要删除元素，使用迭代器
* 仅仅只想遍历，使用增强for

## 9-2-List

### 10-List的特点

单列集合分为`List`和`Set`，都实现了`Collection`接口。List又分为`ArrayLis`t和`LinkedList`。

`List`集合特点：

* 有序：存储和取出的元素顺序一致
* 有索引：可以通过索引操作元素
* 可重复：存储的元素可以重复

### 11-List特有方法

| 方法名                          | 描述                                   |
| ------------------------------- | -------------------------------------- |
| void add(int index,E   element) | 在此集合中的指定位置插入指定的元素     |
| E remove(int   index)           | 删除指定索引处的元素，返回被删除的元素 |
| E set(int index,E   element)    | 修改指定索引处的元素，返回被修改的元素 |
| E get(int   index)              | 返回指定索引处的元素                   |

### 12-栈和队列

**栈**

因为只有一端开口，<span style="background-color:pink;">后进先出</span>。

![image-20230508211633942](http://www.iocaop.com/images/2023-05/image-20230508211633942.png)

**队列**

两端口，先进先出。

![image-20230508211851422](http://www.iocaop.com/images/2023-05/image-20230508211851422.png)

### 13-数组和链表

**数组**

![image-20230508212042398](http://www.iocaop.com/images/2023-05/image-20230508212042398.png)

查询快，增删慢。

为什么？

* 查询数据通过地址值和索引定位，查询任意数据耗时相同，查询速度快。
* 删除数据时，要将原始数据删除，同时后面每个元素前移，删除效率低。
* 添加数据时，添加位置后的每个数据右移，再添加元素，添加效率极低。

**链表**

![image-20230508212435696](http://www.iocaop.com/images/2023-05/image-20230508212435696.png)

图上节点中记录的是下一个元素的地址值，而不是值，图没画好。

上一个节点中记录下一个节点的地址值，形成链表。这是单链表。

对比数组，链表是一种增删快的模型。

添加删除时改变指针即可。

查询时，因为链表的<span style="background-color:pink;">元素所占内存是不连续的</span>，所以只能从head节点开始通过指针一个个往下找，查询慢。

链表又分单向链表、双向链表、循环链表等等。

![image-20230508213211792](http://www.iocaop.com/images/2023-05/image-20230508213211792.png)

### 14-ArrayList源码浅读

当我们调用<span style="background-color:pink;">空参构造创建</span>`ArrayList`时，会创建一个<span style="background-color:pink;">长度为0</span>的数组。再次向这个数组添加一个元素时，会<span style="background-color:pink;">重新创建一个长度为10的数组</span>，所以我们默认认为`ArrayList`底层数组默认长度为10，这个数组名称为`elementData`。

同时还会有一个变量`size`记录下一次插入时的索引值，同时也表示着当前ArrayList的元素的个数。

![image-20230508214643242](http://www.iocaop.com/images/2023-05/image-20230508214643242.png)

当元素个数超出底层数组长度时，会再次创建一个数组，长度是原来的<span style="background-color:pink;">1.5倍</span>，（在JDK 7及以下版本中是扩大为原来的2倍），并且会把原来数组的所有元素拷贝到新的数组中，`size`的值不变，然后再次插入。

![image-20230508214855095](http://www.iocaop.com/images/2023-05/image-20230508214855095.png)

查询数据：直接通过数组地址+索引获取。

看代码：

* 空参构造，底层创建一个长度为0的数组。关于`elementData`修饰符解释：<a href='https://www.cnblogs.com/xiaopan-cp9/p/15439454.html'>点击跳转</a>

![image-20230508214339019](http://www.iocaop.com/images/2023-05/image-20230508214339019.png)

* 向空ArrayList中添加一个元素时：

![image-20230508233248579](http://www.iocaop.com/images/2023-05/image-20230508233248579.png)

将元素、底层数组、size(当前集合元素个数)传递给如下add方法：

![image-20230508233435248](http://www.iocaop.com/images/2023-05/image-20230508233435248.png)

判断，如果当前集合元素个数等于底层数组长度，则进行扩容(调用grow方法)，否则进行数组赋值，size自增。

![image-20230508233626396](http://www.iocaop.com/images/2023-05/image-20230508233626396.png)

![image-20230508233819266](http://www.iocaop.com/images/2023-05/image-20230508233819266.png)

可以看到，将size+1后传递给了带参的扩容方法，使用了`Arrays`工具类的拷贝方法，将新数组赋值给了底层数组，新的数组复制了原来的所有值，且容量更大。

计算新数组长度的方法：

```java
    private int newCapacity(int minCapacity) {
        // minCapacity为size+1
        // overflow-conscious code
        // 取底层数组长度
        int oldCapacity = elementData.length;
        // 计算新数组长度，即旧容量+旧容量的一半(右移移位是除以2)，扩大1.5倍。
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        // 如果计算出来的新容量小于当前size+1，则再次进行判断，否则跳到return。 
        // 空集合第一次添加元素，minCapacity=0+1=1，newCapacity=0+0/2=0。满足条件，即新容量小于size+1.
        if (newCapacity - minCapacity <= 0) {
            // 底层数组是否未默认的空数组
            if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)
                // 如果是，则比较默认定义好的大小(10)和minCapacity，返回大的，调试时，空集合第一次添加一个元素情况，返回DEFAULT_CAPACITY
                return Math.max(DEFAULT_CAPACITY, minCapacity);
            // size+1小于0的话，说明溢出了int取值范围
            if (minCapacity < 0) // overflow
                throw new OutOfMemoryError();
            // 新容量小于原来的容量，且不是默认数组，则说明不需要扩容。
            return minCapacity;
        }
        // 判断新容量是否在ArrayList允许的最大范围 int最大取值范围减8
        return (newCapacity - MAX_ARRAY_SIZE <= 0)
            ? newCapacity
            // 如果超过了，就调用如下方法重新计算
            : hugeCapacity(minCapacity);
    }
```

当新计算出来的容量超过int最大值时重新计算的方法：

```java
    private static int hugeCapacity(int minCapacity) {
        if (minCapacity < 0) // overflow
            throw new OutOfMemoryError();
        return (minCapacity > MAX_ARRAY_SIZE)
            ? Integer.MAX_VALUE
            : MAX_ARRAY_SIZE;
    }
```

为什么要多一层判断？

> 这是因为数组的索引从0开始，而不是1。如果MAX_ARRAY_SIZE等于Integer.MAX_VALUE，则分配一个长度为MAX_ARRAY_SIZE的数组将导致数组索引超出int类型的最大值。因此，MAX_ARRAY_SIZE需要比int类型的最大值小至少1，以确保安全使用。另外8的值可能与VM使用的一些空间大小有关。

### 15-LinkedList基本使用

```java
public class CollectionDemo08 {
    public static void main(String[] args) {
        LinkedList<String> list = new LinkedList<>();
        list.add("aaa");
        list.add("bbb");
        list.add("ccc");
        list.add("ddd");
        for (int i = 0; i < list.size(); i++) {
            System.out.println(list.get(i));
        }

        for (String s : list) {
            System.out.println(s);
        }

        Iterator<String> iterator = list.iterator();
        while (iterator.hasNext()){
            System.out.println(iterator.next());
        }
    }
}
```

### 16-LinkedList特有方法

![image-20230509125509409](http://www.iocaop.com/images/2023-05/image-20230509125509409.png)

```java
public class CollectionDemo09 {
    public static void main(String[] args) {
        LinkedList<String> list = new LinkedList<>();
        list.add("aaa");
        list.add("bbb");
        list.add("ccc");
        list.addFirst("111");
        list.addLast("222");
        System.out.println("list = " + list);
        System.out.println("list.getFirst() = " + list.getFirst());
        System.out.println("list.getLast() = " + list.getLast());
        list.removeFirst();
        System.out.println("list = " + list);
        list.removeLast();
        System.out.println("list = " + list);
    }
}
```

![image-20230509130531350](http://www.iocaop.com/images/2023-05/image-20230509130531350.png)

### 17-LinkedList源码浅读

`LinkedList`底层是双向链表：

![image-20230509125922893](http://www.iocaop.com/images/2023-05/image-20230509125922893.png)

按`ctrl+f12`可以查找类中成员。

可以找到`Node`是`LinkedList`中的一个内部类，就是节点。内部类`Node`对象，就是`LinkedList`中的节点对象。

```java
    private static class Node<E> {
        // 数据
        E item;
        // 前置指针
        Node<E> next;
        // 后置指针
        Node<E> prev;
		// 全参构造
        Node(Node<E> prev, E element, Node<E> next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
    }
```

`LinkedList`中维护了两个核心的成员变量：

![image-20230509131046276](http://www.iocaop.com/images/2023-05/image-20230509131046276.png)

创建好空的`LinkedList`后，链表为空，只有头结点和尾结点，此时`LinkedList`对象在堆内存中如下：

且都为null

![image-20230509164642578](http://www.iocaop.com/images/2023-05/image-20230509164642578.png)

添加元素时调用:

```java
    public boolean add(E e) {
        linkLast(e);
        return true;
    }
```

```java
    void linkLast(E e) {
        // 定义节点变量l 和last指向同一变量
        final Node<E> l = last;
        // 调用Node的带参构造，创建新节点,新节点的前置指针为l，
        // 因为l是添加这个节点之前的尾节点。后置指针为null
        final Node<E> newNode = new Node<>(l, e, null);
        // 将新创建出来的节点设置为尾结点
        last = newNode;
        // 判断创建新节点前，尾结点是否为null
        if (l == null)
            // 是则表示第一次添加元素，赋给头结点
            first = newNode;
        else
            // 否则将新节点作为尾节点并和添加新节点之前的尾结点连接
            l.next = newNode;
        size++;
        modCount++;
    }
```

```java
    private static class Node<E> {
        E item;
        Node<E> next;
        Node<E> prev;

        Node(Node<E> prev, E element, Node<E> next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
    }
```

添加了一个元素后：

`LinkedList`中的两个变量`first`和`last`都被赋值为了这个`Node`对象，即新元素。图中节点都是在堆内存中，方便看，所以画在外面。

![3f683f120ec940e66653b1d26b019d4](http://www.iocaop.com/images/2023-05/3f683f120ec940e66653b1d26b019d4.jpg)

添加第二个元素时，`first`不变，第二个元素变为`last`，第一个元素`aaa`的next被赋值为了第二个元素，也就是第一个元素的next指针指向第二个元素。同时第二个元素`bbb`的prev又指向了`aaa`，在代码中可以看到，调用全参构造的时候把`l`传过去了。`l`的作用就是记录添加元素前的尾结点，用于创建下一个节点。图中节点都是在堆内存中，方便看，所以画在外面。

![97b9ae90da6b41890e85d9639033a1c](http://www.iocaop.com/images/2023-05/97b9ae90da6b41890e85d9639033a1c.jpg)

以此类推，不需要扩容，动态new出来的节点，设置好指针即可。

查找元素时源码：

```java
    public E get(int index) {
        checkElementIndex(index);
        return node(index).item;
    }
```

```java
    Node<E> node(int index) {
        // assert isElementIndex(index);
		// 将链表长度除以2，和需要查找的索引值进行比较，判断从头结点开始找还是从尾节点开始找
        if (index < (size >> 1)) {
            // 从头结点开始找，则让x为LinkedList对象中的first成员，因为他记录了头节点
            Node<E> x = first;
            // 按指定次数移动指针，每次赋值x为x的next指向的元素
            for (int i = 0; i < index; i++)
                x = x.next;
            return x;
        } else {
           // 从头结点开始找，则让x为LinkedList对象中的last成员，因为他记录了尾节点
            Node<E> x = last;
            for (int i = size - 1; i > index; i--)
                 // 按指定次数移动指针，每次赋值x为x的prev指向的元素
                x = x.prev;
            return x;
        }
    }
```

删除元素时：

```java
    public boolean remove(Object o) {
        // 分两种情况，被删除的元素是null，则循环查找为null的元素，调用unlink从链表中移除
        if (o == null) {
            for (Node<E> x = first; x != null; x = x.next) {
                if (x.item == null) {
                    unlink(x);
                    return true;
                }
            }
        } else {
            // 被删除的元素不为null,则循环查找元素，调用equals方法比较，结果为true的，调用unlink从链表中移除
            for (Node<E> x = first; x != null; x = x.next) {
                if (o.equals(x.item)) {
                    unlink(x);
                    return true;
                }
            }
        }
        return false;
    }
```

unlink方法：

```java
    E unlink(Node<E> x) {
        // assert x != null;
        // 记录被删除的元素的数据区
        final E element = x.item;
        // 记录被删除的元素的后置指针，在Java中就是后一个节点
        final Node<E> next = x.next;
        // 记录被删除的元素的前置指针，在Java中就是前一个节点
        final Node<E> prev = x.prev;
		// 如果被删除的元素的前置指针为null，说明被删除的元素是头结点
        if (prev == null) {
            // 设置整个链表的新的头节点为被删除的元素的下一个节点
            first = next;
        } else {
            // 被删除的元素不是链表的头结点，则设置被删除的元素的上一个节点的next节点为被删除的元素的下一个节点
            prev.next = next;
            // 置空被删除的元素的前置指针
            x.prev = null;
        }
		// 如果被删除的元素的后置指针为null，说明被删除的元素是尾结点
        if (next == null) {
            //设置整个链表的新的尾结点为被删除的元素的上一个节点
            last = prev;
        } else {
            // 被删除的元素不是链表的尾结点，则设置被删除的元素的下一个节点的前置指针为被删除的元素的上一个节点
            next.prev = prev;
            // 被删除的元素的后置指针为null
            x.next = null;
        }
		// 设置被删除元素的数据区为null
        x.item = null;
        size--;
        modCount++;
        return element;
    }
```

## 9-3-Set

### 01~02-概述和基本使用

单列集合`Collection`分为`List`和`Set`，`Set`又分为`HashSet`和`TreeSet`。`Set`集合最主要的特点就是不可重复，所有可以去除重复。

特点：

* 元素不可重复
* 元素存取顺序不一致
* 没有带索引的方法，不能通过普通for来遍历，也不能通过索引获取、删除元素

基本使用：

实现类有`TreeSet`和`HashSet`，没有索引：

![image-20230510001641556](http://www.iocaop.com/images/2023-05/image-20230510001641556.png)

```java
public class CollectionDemo10 {
    public static void main(String[] args) {
        Set<String> set = new TreeSet<>();
        set.add("aaa");
        set.add("bbb");
        set.add("ccc");
        set.add("ddd");
        // 没有索引，所以通过迭代器来遍历
        Iterator<String> iterator = set.iterator();
        while (iterator.hasNext()){
            System.out.println("iterator.next() = " + iterator.next());
        }
        // 增强for原理也是迭代器,Collection实现了Iterable，所以可以使用增强for来遍历
        for (String s : set) {
            System.out.println("s = " + s);
        }
    }
}
```

![image-20230510001842143](http://www.iocaop.com/images/2023-05/image-20230510001842143.png)

为了验证元素不重复和存取顺序不一致。稍微调整：

![image-20230510002006362](http://www.iocaop.com/images/2023-05/image-20230510002006362.png)

### 03-TreeSet基本使用

`TreeSet`集合特点：

* 不包含重复元素的集合
* 没有带索引的方法
* <span style="background-color:pink;">可以将元素按照规则排序</span>

```java
public class CollectionDemo11 {
    public static void main(String[] args) {
        Set<Integer> set = new TreeSet<>();
        set.add(1);
        set.add(5);
        set.add(3);
        set.add(4);
        set.add(2);
        set.add(2);
        System.out.println("set = " + set);
    }
}
```

从结果中可以看到，已经帮我们排序了。

![image-20230510002410237](http://www.iocaop.com/images/2023-05/image-20230510002410237.png)

那么自定义类型能排序吗？

自定义`Student`类，创建几个对象，测试能否帮我们排序：

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class Student {

    /**
     * 名字
     */
    private String name;

    /**
     * 年龄
     */
    private Integer age;
}
```

```java
public class CollectionDemo12 {
    public static void main(String[] args) {
        TreeSet<Student> set = new TreeSet<>();
        set.add(new Student("小敏",15));
        set.add(new Student("小红",16));
        set.add(new Student("小明",19));
        set.add(new Student("小花",23));
        set.add(new Student("小赖",25));
        System.out.println("set = " + set);
    }
}
```

运行报错了：

![image-20230510002900994](http://www.iocaop.com/images/2023-05/image-20230510002900994.png)

为什么报错？

`TreeSet`可以按照<span style="background-color:pink;">规则</span>排序，必须要指定排序规则。

### 04-TreeSet自然排序Comparable使用

* 使用空参构造创建`TreeSet`集合
* 自定义`Student`类实现`Comparable`接口
* 重写里面的`compareTo`方法

文档：

![image-20230510010311965](http://www.iocaop.com/images/2023-05/image-20230510010311965.png)

修改`Student`类，实现`Comparable`接口，重写`compareTo`方法：

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class Student implements Comparable<Student>{

    /**
     * 名字
     */
    private String name;

    /**
     * 年龄
     */
    private Integer age;

    @Override
    public int compareTo(Student o) {
        // 按照对象年龄进行排序
        return this.age-o.age;
    }
}

```

再次运行，可以看到已经按照年龄大小将`Student`对象进行排序了：

![image-20230510010616402](http://www.iocaop.com/images/2023-05/image-20230510010616402.png)

自然排序简单原理：

* `compareTo`返回负数，表示当前存入的值是较小值，放左边。
* `compareTo`返回0，表示当前存入的值跟已有元素重复，不存。
* `compareTo`返回正数，表示当前存入的值是较大值，放右边。

假设现在`TreeSet`中已有一个元素，age为28，再存一个age为27的`Student`对象，则调用`compareTo`进行比较，this就是当前要存的对象，比较后，27-28返回负数，说明要放在左边。

![image-20230510011024088](http://www.iocaop.com/images/2023-05/image-20230510011024088.png)

再存一个age为29的`Student`对象，`compareTo`，29-27=2返回了正数，说明要放在右边

![image-20230510011037394](http://www.iocaop.com/images/2023-05/image-20230510011037394.png)

发现右边还有元素，再比较一次，29-28=1返回正数，说明要放右边，得到最终结果。

![image-20230510011045373](http://www.iocaop.com/images/2023-05/image-20230510011045373.png)

![image-20230510011054345](http://www.iocaop.com/images/2023-05/image-20230510011054345.png)

### 05-自然排序练习

需求：`Student`存入`TreeSet`，按照年龄排序，如果年龄一样，则按照姓名首字母排序，如果姓名年龄都一样，则认为重复，不存入了。

先看一个现象：上面代码，增加一个年龄、姓名不一样的`Student`对象，再输出`TreeSet`，发现，后面添加的对象没有存入。

![image-20230510011939898](http://www.iocaop.com/images/2023-05/image-20230510011939898.png)

为什么会这样？

按照自然排序原理以及我们重写的`compareTo`方法可以知道，当age相同时，会认为`TreeSet`中元素重复，不进行存入，显然是不符合需求的。

所以需要修改我们重写的`compareTo`方法：

```java
    @Override
    public int compareTo(Student o) {
        // 按照对象年龄进行排序  this对象(要存入的对象)的年龄-参数对象(当前比较对象)o的年龄
        int result = this.age-o.age;
        result = result==0?this.getName()
            // 这个方法是String类中重写的，按照字典顺序进行比较
            .compareTo(o.getName()):result;
        return result;
    }
```

再次运行：

![image-20230510012457831](http://www.iocaop.com/images/2023-05/image-20230510012457831.png)

为了验证先按年龄排序，如果年龄相同就再按照姓名首字母排序，修改姓名为英文的：

![image-20230510012715027](http://www.iocaop.com/images/2023-05/image-20230510012715027.png)

> `String`中`compareTo`方法是逐个比较ASCII值，相同则比较下一个字符，不相同则返回ASCII码值的差。

### 06-比较器排序

需求：使用比较器的方式，将老师对象存入`TreeSet`集合，按年龄排序，如果年龄一样，则按照姓名首字母排序。

当没有比较器时，添加元素到集合会报错

```java
public class CollectionDemo13 {
    public static void main(String[] args) {
        TreeSet<Teacher> treeSet = new TreeSet<>();
        Teacher t1 = new Teacher("zhangsan", 23);
        Teacher t2 = new Teacher("lisi", 22);
        Teacher t3= new Teacher("wangwu", 24);
        Teacher t4 = new Teacher("zhaoliu", 24);
        treeSet.add(t1);
        treeSet.add(t2);
        treeSet.add(t3);
        treeSet.add(t4);
    }
}

```

看构造函数：

![image-20230510211143685](http://www.iocaop.com/images/2023-05/image-20230510211143685.png)

构造函数可以传入比较器的实现类对象，查看比较器：

![image-20230510211252297](http://www.iocaop.com/images/2023-05/image-20230510211252297.png)

可以使用匿名内部类或者lamda表达式进行重写，修改代码：

```java
public class CollectionDemo13 {
    public static void main(String[] args) {
        TreeSet<Teacher> treeSet = new TreeSet<>((o1, o2) -> {
            int result = o1.getAge() - o2.getAge();
            result = result == 0 ? o1.getName().compareTo(o2.getName()) : result;
            return result;
        });
        Teacher t1 = new Teacher("zhangsan", 23);
        Teacher t2 = new Teacher("lisi", 22);
        Teacher t3 = new Teacher("wangwu", 24);
        Teacher t4 = new Teacher("zhaoliu", 24);
        treeSet.add(t1);
        treeSet.add(t2);
        treeSet.add(t3);
        treeSet.add(t4);
        System.out.println("treeSet = " + treeSet);
    }
}
```

![image-20230510211455751](http://www.iocaop.com/images/2023-05/image-20230510211455751.png)

运行可以看到，结果满足要求。按照年龄进行排序了，且年龄相同的就按名字首字母排序。

### 07-两种比较方式的对比

* 自然排序：自定义类实现`Comparable`接口，重写`CompareTo`方法， 根据返回值排序。
* 比较器排序：创建`TreeSet`对象的时候传递`Comparator`的实现来对象，重写`CompareTo`方法， 根据返回值排序。

两种比较方式都是一样，按找第四节课的比较器原理来插入元素。

有什么区别？

在使用的时候，默认使用自然排序，当自然排序不满足需求时，就使用比较器排序。比如：

要按照字符串长度排序，如果字符串长度一样，则按照字典排序，但是`String`类已经实现了自然排序接口，我们又不能改`String`类的源码。这时就需要使用比较器排序，在创建`TreeSet`对象时传入比较器实现类对象。

![image-20230510212309522](http://www.iocaop.com/images/2023-05/image-20230510212309522.png)

```java
        TreeSet<String> set = new TreeSet<>(((o1, o2) -> {
            int result = o1.length() - o2.length();
            result = result == 0 ? o1.compareTo(o2) : result;
            return result;
        }));
```

### 08-二叉树

![image-20230515225104733](http://www.iocaop.com/images/2023-05/image-20230515225104733.png)

树节点每个节点的子节点数称为<span style="background-color:pink;">度</span>。

二叉树：任意节点的度小于等于2。

根节点的左子树、右子树是什么？

![image-20230515225651888](http://www.iocaop.com/images/2023-05/image-20230515225651888.png)

### 09-二叉查找树

![image-20230515225755964](http://www.iocaop.com/images/2023-05/image-20230515225755964.png)

二叉查找树又称二叉排序树或二叉搜索树，特点如下：

* 每个节点最多有两个节点，即二叉树
* 每个节点的左子节点都小于自己
* 每个节点的右节点都大于自己

### 10-二叉查找树添加节点

每次添加节点时从根节点开始比较，决定放在左边还是右边。一直递归这个操作。

参考：<a href='https://blog.lufficc.com/binary-search-tree/'>点击跳转</a>

### 11-平衡二叉树

将7、10、11、12、13依次添加到二叉查找树中，最终得到的结果如下：

![image-20230515231025741](http://www.iocaop.com/images/2023-05/image-20230515231025741.png)

会发现，拉链过长，变成了链表，查询效率太低，因为二叉查找树也是从根节点开始找的，如果要查13，那么这个树要查5次。要提高查询效率，要在二叉查找树的基础上，让左右子树的高度尽量相同。

平衡二叉树应该满足以下要求：

* 二叉树左右子树高度差不超过1
* <span style="background-color:pink;">任意节点的左右子树都是一颗平衡二叉树</span>

![image-20230515231502533](http://www.iocaop.com/images/2023-05/image-20230515231502533.png)

节点10不满足要求，左子树高度0，右子树高度3，超过1。

### 12-平衡二叉树左旋

先说说平衡二叉树的引出：

* 二叉树查找效率低，要一个个遍历。

  ![ ](http://www.iocaop.com/images/2023-05/image-20230515233012763.png)

* 所以有了二叉查找树，因为二叉查找树中的每个节点的左子节点都小于自己，每个节点的右节点都大于自己。查找一个节点的最坏情况也只需要树的高度那么多次。

  ![image-20230515233231201](http://www.iocaop.com/images/2023-05/image-20230515233231201.png)

* 二叉查找树会有退化成链表的情况，导致查找次数变多，所以引出了二叉平衡树，使得每个节点的左右子树高度差不超过1，降低树的高度来减少查询次数。

  ![image-20230515233246416](http://www.iocaop.com/images/2023-05/image-20230515233246416.png)

为了维持平衡二叉树，需要进行左旋和右旋。

触发时机：<span style="background-color:pink;">当添加一个节点后，该树不再是平衡二叉树。</span>

<span style="background-color:pink;">旋转的目的</span>就是保证这棵树再次变为一颗平衡二叉树。

**简单的左旋**：

平衡二叉树：

![image-20230516000621570](http://www.iocaop.com/images/2023-05/image-20230516000621570.png)

添加一个节点12后，发现根节点左子树高度1，根节点右子树高度3，失去平衡。

![image-20230516000634055](http://www.iocaop.com/images/2023-05/image-20230516000634055.png)

因为根节点右子树高度大于根节点左子树，所以需要进行左旋：

![image-20230516000653509](http://www.iocaop.com/images/2023-05/image-20230516000653509.png)

稍微复杂一点的左旋：

平衡二叉树：

![](http://www.iocaop.com/images/2023-05/image-20230516000954528.png)

由于添加了节点12，失去平衡：

![image-20230516001026521](http://www.iocaop.com/images/2023-05/image-20230516001026521.png)

因为跟节点右子树高度为3，根节点左子树高度为1，所以需要左旋，左旋时，假设节点9不存在，只需要记住，9节点是10节点的左子节点：

![image-20230516001123877](http://www.iocaop.com/images/2023-05/image-20230516001123877.png)

补上9节点：
![image-20230516001202601](http://www.iocaop.com/images/2023-05/image-20230516001202601.png)

将9节点作为7节点的右子节点：

![image-20230516001231139](http://www.iocaop.com/images/2023-05/image-20230516001231139.png)

<span style="background-color:pink;">左旋：将将根节点的右侧往左拉，原先的右子节点变为新的跟节点，并把多余的左子节点出让，给已经降级的根节点当右子节点</span>

## 9-3-泛型

### 18-概述

```java
public class GenericsDemo01 {
    public static void main(String[] args) {
        ArrayList list = new ArrayList<>();

        list.add("aaa");
        list.add("bbb");

        Iterator iterator = list.iterator();
        while (iterator.hasNext()){
            Object next = iterator.next();
            System.out.println("next = " + next);
        }
    }
}
```

看这段代码，虽然不写泛型，也不会报错，依然正常运行：

![image-20230510213629679](http://www.iocaop.com/images/2023-05/image-20230510213629679.png)

但是获取到的对象是`Object`类型，无法使用对象中的方法，要使用必须强转：

![image-20230510213716730](http://www.iocaop.com/images/2023-05/image-20230510213716730.png)

![image-20230510213756593](http://www.iocaop.com/images/2023-05/image-20230510213756593.png)

再看，如果不写泛型，默认是`Object`，可以添加任意类型的对象，这时添加数字会怎么样？编译不报错，运行会报错：因为我们遍历时做了类型强转，`Integer`强转`String`报错了。

![image-20230510213915933](http://www.iocaop.com/images/2023-05/image-20230510213915933.png)

引出泛型：

jdk5想特性，提供了<span style="background-color:pink;">编译时类型安全检测机制</span>。

好处：

* 把运行期间的问题提前到了编译期间。
* 避免了强制类型转换。

### 19-泛型类的使用

什么地方可以使用泛型？

* 类后面---泛型类
* 方法申明上---泛型方法
* 接口后面---泛型接口

平时开发最常用的泛型类就是`ArrayList`:

![image-20230510214602755](http://www.iocaop.com/images/2023-05/image-20230510214602755.png)

如果一个类后面有类似\<E\>，表示这个类是一个泛型类。

创建泛型类对象时，必须要给这个泛型确定具体的数据类型。

比如:

```java
        ArrayList<String> list = new ArrayList<>();
```

就在创建集合时确定了这个集合对象存储的元素类型，存储的不是`String`类型，就会在编译期间报错。

### 20-自定义泛型类

泛型定义的格式：

* <类型>：指定一种类型格式，括号里可以任意书写，按照变量的定义规则即可，一般只写一个字母，如：

  ```java
  <Q> <T> <K> <V>
  ```

* <类型1，类型2，...>：指定多种类型的格式，多种类型用逗号隔开

  ```java
  <K,V> <E,T> <Q,M>
  ```

泛型类的定义：

```java
public class 类名<泛型类型>{}
```

如：

```java
public class Generic<T>{}
// 此处T可以随便写任意标识，常见的有T、E、K、V等形式参数表示泛型
```

```java
public class GenericsDemo02 {
    public static void main(String[] args) {
        // 泛型为String的box对象
        Box<String> stringBox = new Box<>();
        stringBox.setElement("给xx的土味情话");
        System.out.println("stringBox = " + stringBox);

        // 泛型为Integer的box对象
        Box<Integer> integerBox = new Box<>();
        integerBox.setElement(25);
        System.out.println("integerBox = " + integerBox);
    }
}
```

![image-20230510233125076](http://www.iocaop.com/images/2023-05/image-20230510233125076.png)

### 21泛型方法的使用

先来学习怎么使用泛型方法，这里拿`ArrayList`中的`toArray`方法演示：

![image-20230510233816850](http://www.iocaop.com/images/2023-05/image-20230510233816850.png)

```java
public class GenericsDemo03 {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("aaa");
        list.add("bbb");
        list.add("ccc");

        // 不使用泛型
        Object[] array = list.toArray();
        System.out.println("Arrays.toString(array) = " + Arrays.toString(array));

        // 使用泛型
        String[] strings = list.toArray(new String[list.size()]);
        System.out.println("Arrays.toString(strings) = " + Arrays.toString(strings));

    }
}
```

![image-20230510234023197](http://www.iocaop.com/images/2023-05/image-20230510234023197.png)

可以看到，不使用泛型也可以正常输出，但是需要强转，使用泛型就不需要强转，返回的就是我们指定的泛型的数组。传入什么类型的数组，就返回什么类型的数组。

![image-20230510234102377](http://www.iocaop.com/images/2023-05/image-20230510234102377.png)

### 22-自定义泛型方法

泛型方法的定义格式：

```java
修饰符 <类型> 返回值类型 方法名(类型 变量名){}
```

举例：

```java
public <T> void show(T t){}
```

> 为什么在修饰符后面又要一个\<T\>，表示定义一个泛型， 不然就会认为show方法中的参数类型T是一个类或者类型。

在定义方法是，T是没有具体类型的，只有在调用时，泛型T才会有具体的类型。

练习：

定义一个泛型方法，传递一个集合和四个元素，将元素添加到集合中并返回。

```java
public class GenericsDemo04 {
    public static void main(String[] args) {
        ArrayList<String> l1 = new ArrayList<>();
        ArrayList<String> stringArrayList = add2List(l1, "aaa", "bbb", "ccc", "ddd");
        System.out.println("stringArrayList = " + stringArrayList);

        ArrayList<Integer> l2 = new ArrayList<>();
        ArrayList<Integer> integerArrayList = add2List(l2, 1, 2, 3, 4);
        System.out.println("integerArrayList = " + integerArrayList);
    }
    
    public static <T> ArrayList<T>add2List(ArrayList<T> list,T t1,T t2,T t3,T t4){
        list.add(t1);
        list.add(t2);
        list.add(t3);
        list.add(t4);
        return list;
    }
}
```

![image-20230511000345443](http://www.iocaop.com/images/2023-05/image-20230511000345443.png)

![image-20230511000351888](http://www.iocaop.com/images/2023-05/image-20230511000351888.png)

### 23-泛型接口

泛型接口的使用方式：

* 实现类中也不给出具体的类型， 继续沿用泛型，如`List<T>`的实现类`ArrayList<T>`：

  ![image-20230511002118759](http://www.iocaop.com/images/2023-05/image-20230511002118759.png)

* 实现类中给出具体的数据类型

泛型接口的定义格式：

* 格式：

  ```java
  修饰符 interface 接口名<类型>{}
  ```

* 举例：

  ```java
  public interfate Generic<T>{}
  ```

```java
public class GenericsDemo05 {

    public static void main(String[] args) {
        // 创建沿用接口泛型的泛型接口实现类对象，不指定泛型，默认Object
        GenericsImpl<String> objectGenerics = new GenericsImpl();
        objectGenerics.print("哈哈哈");

        // 创建沿用接口泛型的泛型接口实现类对象，指定泛型为Integer
        GenericsImpl<Integer> integerGenerics = new GenericsImpl();
        integerGenerics.print(123);

        // 创建沿用接口泛型的泛型接口实现类对象，指定泛型为Double
        GenericsImpl<Double> doubleGenerics = new GenericsImpl();
        doubleGenerics.print(123.321);

        // 创建给出具体类型的泛型接口实现类对象 实现类已经给出具体类型，只能用Integer
        GenericsIntegerImpl genericsInteger = new GenericsIntegerImpl();
        genericsInteger.print(321);
    }
}

/**
 * 泛型接口
 *
 * @author lzc
 * @date 2023/05/11
 */
interface Generics<E> {
    public abstract void print(E e);
}

/**
 * 泛型impl 不给出具体类型，沿用接口的泛型
 *
 * @author lzc
 * @date 2023/05/11
 */
class GenericsImpl<E> implements Generics<E>{
    @Override
    public void print(E e) {
        System.out.println("e = " + e);
    }
}

/**
 * 泛型impl  给出具体的类型为Integer，实现泛型接口
 *
 * @author lzc
 * @date 2023/05/11
 */
class GenericsIntegerImpl implements Generics<Integer>{
    @Override
    public void print(Integer integer) {
        System.out.println("integer = " + integer);
    }
}

```

![image-20230511003625162](http://www.iocaop.com/images/2023-05/image-20230511003625162.png)

### 24-通配符

概述：

* 类型通配符`<?>`
* `ArrayList<?>`表示元素类型位置的`ArrayList`，它的元素可以匹配任何类型
* 但是并不能把元素添加到`ArrayList`中了，因为获取出来的也是父类类型

类型通配符作用：

* 类型通配符上限限定：<? extends 类型>

如：`ArrayList<? extends Number>`：表示类型是`Nubmber`或者其子类型。

* 类型通配符下限限定：<? extends 类型>

```java
public class GenericsDemo06 {

    public static void main(String[] args) {
        ArrayList<Number> list1 = new ArrayList<>();

        ArrayList<Integer> list2 = new ArrayList<>();

        ArrayList<Object> list3 = new ArrayList<>();
        
        method1(list1);
        method1(list2);
        // 限制元素? extends Number，传入Object报错，Object不是Number的子类
        method1(list3);
        
        method2(list1);
        // 限制元素? super Number，传入Integer报错，Integer不是Number的父类，而是子类
        method2(list2);
        method2(list3);

    }
    
    public static void method1(ArrayList<? extends Number> list){
        // ? extends Number 表示集合中的元素是Number或者Number的子类
    }
    public static void method2(ArrayList<? super Number> list){
        // ? super Number 表示集合中的元素是Number或者Number的父类
    }
}
```

![image-20230511005458263](http://www.iocaop.com/images/2023-05/image-20230511005458263.png)
