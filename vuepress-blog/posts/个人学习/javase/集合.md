---
title: java基础-集合
date: 2023-05-06
category:
  - JavaSE
---

## 9-1-Collection

### 01-集合与数组对比

* 数组的长度是不可变的，集合的长度是可变的。
* 数组可以存基本数据类型和引用数据类型。集合只能存引用数据类型，如果集合要存基本数据类型，需要存对应的<span style="background-color:pink;">包装类</span>。

### 02-集合体系结构

![image-20230506004215802](http://www.iocaop.com/images/2023-05/image-20230506004215802.png)

### 03-Collection常见成员方法

Collection概述和使用：

* 是单列集合的顶层接口，他表示一组对象，这些对象也称为`Collection`的元素
* JDK不提供此接口的任何实现。提供更具体的子接口(如`List`、`Set`)的实现。

创建Collection集合的对象

* 多态的方式
* 具体的实现类`ArrayList`

常用成员方法：

![image-20230506004713015](http://www.iocaop.com/images/2023-05/image-20230506004713015.png)

除了removeif方法，其他方法都比较常规。

```java
public class CollectionDemo01 {
    public static void main(String[] args) {
        Collection<String> list = new ArrayList<>();
        list.add("aaa");
        list.add("bbb");
        list.add("ccc");
        list.add("aaaa");
        list.removeIf(s->s.length()==3);
        System.out.println("list = " + list);
    }
}
```

![image-20230506010046853](http://www.iocaop.com/images/2023-05/image-20230506010046853.png)

参数是一个函数式接口，可以使用lamda表达式，会遍历整个集合，进行满足条件的就会进行删除。

解释：传入`Predicate`实现类，该方法会获取集合的迭代器，遍历集合元素，并调用实现类的`test`方法，逐个进行判断，如果实现类的`test`方法结果为`true`，则删除元素。

### 04-迭代器的基本使用

Collection接口中有获取迭代器对象的抽象方法：是由实现类提供具体实现。

![image-20230508101824877](http://www.iocaop.com/images/2023-05/image-20230508101824877.png)

作用：返回集合中的迭代器对象，该迭代器对象默认指向当前集合的0索引。

迭代器`Iterator`中的方法：

![image-20230508102050231](http://www.iocaop.com/images/2023-05/image-20230508102050231.png)

使用迭代器遍历集合：

```java
public class CollectionDemo03 {
    public static void main(String[] args) {
        Collection<String> list = new ArrayList<>();
        list.add("a");
        list.add("b");
        list.add("c");
        list.add("d");
        // 1 获取迭代器对象。迭代器对象一旦创建出来，默认指向0索引
        Iterator<String> iterator = list.iterator();


        // 2 利用迭代器中的方法来遍历集合
        // 迭代器当前指向位置是否有元素可以取出
        boolean b = iterator.hasNext();
        System.out.println(b);
        // next()方法做了两件事情，1取出当前位置元素 2将迭代器往后移动一个索引的位置
        System.out.println("iterator.next() = " + iterator.next());

        System.out.println("iterator.next() = " + iterator.next());
        System.out.println("iterator.next() = " + iterator.next());
        System.out.println("iterator.next() = " + iterator.next());
        System.out.println("iterator.next() = " + iterator.next());

    }
}
```

会报错：

![image-20230508102911014](http://www.iocaop.com/images/2023-05/image-20230508102911014.png)

> 为什么会报错？因为只有4个元素，却调用了5次next()方法，第五次调用时，迭代器指向的位置已经超出了集合索引范围。所以报错了

为了防止报错，在遍历时需要调用`hasNext()`方法，判断迭代器当前指向位置是否有元素可以取出。

```java
public class CollectionDemo03 {
    public static void main(String[] args) {
        Collection<String> list = new ArrayList<>();
        list.add("a");
        list.add("b");
        list.add("c");
        list.add("d");
        // 1 获取迭代器对象。迭代器对象一旦创建出来，默认指向0索引
        Iterator<String> iterator = list.iterator();
        
        // 2 利用迭代器中的方法来遍历集合
        // 迭代器当前指向位置是否有元素可以取出
        boolean b = iterator.hasNext();
        System.out.println(b);
        // next()方法做了两件事情，1取出当前位置元素 2将迭代器往后移动一个索引的位置
        while (iterator.hasNext()){
            System.out.println("iterator.next() = " + iterator.next());
        }
    }
}
```

### 05-迭代器原理

![image-20230508103621647](http://www.iocaop.com/images/2023-05/image-20230508103621647.png)

当迭代器指向最后一个元素时，`hasNext()`方法返回是false。原理个锤子。

### 06-迭代器的删除方法

先写个删除方法：删除集合中字符串为“b”的元素

```java
public class CollectionDemo04 {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("a");
        list.add("b");
        list.add("b");
        list.add("c");
        list.add("d");

        for (int i=0;i<list.size();i++){
            if ("b".equals(list.get(i))){
                list.remove(i);
            }
        }
        System.out.println("list = " + list);
    }
}
```

![image-20230508104225096](http://www.iocaop.com/images/2023-05/image-20230508104225096.png)

可以看到，有个元素明明是"b"却没有被删除，当我们换一下元素位置为：abcbd时(重复元素不连续)又能删除了：

![image-20230508104351060](http://www.iocaop.com/images/2023-05/image-20230508104351060.png)

为什么？

java中的List集合是动态的，当删除一个元素后，长度会自动减1，如图，删除索引1后，长度减1，索引又移动到2了，导致漏了一个元素没有被遍历到。

![image-20230508104652528](http://www.iocaop.com/images/2023-05/image-20230508104652528.png)

![image-20230508104712196](http://www.iocaop.com/images/2023-05/image-20230508104712196.png)

如何解决？

当成功删除后，索引往前移一个位置。

![image-20230508105037290](http://www.iocaop.com/images/2023-05/image-20230508105037290.png)

如果使用迭代器，就不会存在这个问题，迭代器的删除方法，是指向谁就删除谁：

```java
public class CollectionDemo05 {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("a");
        list.add("b");
        list.add("b");
        list.add("c");
        list.add("d");
        Iterator<String> iterator = list.iterator();
        while (iterator.hasNext()){
            String next = iterator.next();
            if ("b".equals(next)){
                // 指向谁就删除谁
                iterator.remove();
            }
        }
        System.out.println("list = " + list);
    }
}
```

gpt的解释：

![image-20230508110950667](http://www.iocaop.com/images/2023-05/image-20230508110950667.png)

迭代器能维护集合状态：

![image-20230508111037732](http://www.iocaop.com/images/2023-05/image-20230508111037732.png)

### 07-增强for

作用：简化<span style="background-color:pink;">数组</span>和<span style="background-color:pink;">Collection集合</span>的遍历

* jdk5以后出现的，内部是一个`Iterator`迭代器
* 实现`Iterable`接口的类才可以使用迭代器和增强for

单列集合顶层`Collection`实现了`Iterable`接口，而双列集合`Map`没有实现该接口。

![image-20230508205244919](http://www.iocaop.com/images/2023-05/image-20230508205244919.png)

![image-20230508205337288](http://www.iocaop.com/images/2023-05/image-20230508205337288.png)

可以得出结论：单列集合都可以使用增强for，而双列集合不行。

格式：

```java
for(元素数据类型 变量名:数组或Collection集合){
// 在此处使用变量即可，该变量就是元素
}
```

举例：

```java
public class CollectionDemo06 {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("a");
        list.add("b");
        list.add("b");
        list.add("c");
        list.add("d");
        // 1.数据类型一定是集合或数组中元素的类型
        // 2.s仅仅是一个变量名而已，在循环的过程中，依次表示集合或数组中的每一个元素
        // 3.list就是要遍历的集合或者数组
        for (String s : list) {
            System.out.println("s = " + s);
        }
    }
}
```

### 08-增强for注意点

```java
public class CollectionDemo07 {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("a");
        list.add("b");
        list.add("b");
        list.add("c");
        list.add("d");
        for (String s : list) {
            s="q";
            System.out.println("s = " + s);
        }
        System.out.println("list = " + list);
    }
}
```

运行结果：

![image-20230508210144493](http://www.iocaop.com/images/2023-05/image-20230508210144493.png)

<span style="background-color:pink;">在增强for中修改变量的值，不会影响集合中的元素</span>

![image-20230508210231708](http://www.iocaop.com/images/2023-05/image-20230508210231708.png)

目前为止学习了三种遍历方式：

* 如果需要操作索引，使用普通for
* 如果再遍历过程中需要删除元素，使用迭代器
* 仅仅只想遍历，使用增强for

## 9-2-List

### 10-List的特点

单列集合分为`List`和`Set`，都实现了`Collection`接口。List又分为`ArrayLis`t和`LinkedList`。

`List`集合特点：

* 有序：存储和取出的元素顺序一致
* 有索引：可以通过索引操作元素
* 可重复：存储的元素可以重复

### 11-List特有方法

| 方法名                          | 描述                                   |
| ------------------------------- | -------------------------------------- |
| void add(int index,E   element) | 在此集合中的指定位置插入指定的元素     |
| E remove(int   index)           | 删除指定索引处的元素，返回被删除的元素 |
| E set(int index,E   element)    | 修改指定索引处的元素，返回被修改的元素 |
| E get(int   index)              | 返回指定索引处的元素                   |

### 12-栈和队列

**栈**

因为只有一端开口，<span style="background-color:pink;">后进先出</span>。

![image-20230508211633942](http://www.iocaop.com/images/2023-05/image-20230508211633942.png)

**队列**

两端口，先进先出。

![image-20230508211851422](http://www.iocaop.com/images/2023-05/image-20230508211851422.png)

### 13-数组和链表

**数组**

![image-20230508212042398](http://www.iocaop.com/images/2023-05/image-20230508212042398.png)

查询快，增删慢。

为什么？

* 查询数据通过地址值和索引定位，查询任意数据耗时相同，查询速度快。
* 删除数据时，要将原始数据删除，同时后面每个元素前移，删除效率低。
* 添加数据时，添加位置后的每个数据右移，再添加元素，添加效率极低。

**链表**

![image-20230508212435696](http://www.iocaop.com/images/2023-05/image-20230508212435696.png)

图上节点中记录的是下一个元素的地址值，而不是值，图没画好。

上一个节点中记录下一个节点的地址值，形成链表。这是单链表。

对比数组，链表是一种增删快的模型。

添加删除时改变指针即可。

查询时，因为链表的<span style="background-color:pink;">元素所占内存是不连续的</span>，所以只能从head节点开始通过指针一个个往下找，查询慢。

链表又分单向链表、双向链表、循环链表等等。

![image-20230508213211792](http://www.iocaop.com/images/2023-05/image-20230508213211792.png)

### 14-ArrayList源码浅读

当我们调用<span style="background-color:pink;">空参构造创建</span>`ArrayList`时，会创建一个<span style="background-color:pink;">长度为0</span>的数组。再次向这个数组添加一个元素时，会<span style="background-color:pink;">重新创建一个长度为10的数组</span>，所以我们默认认为`ArrayList`底层数组默认长度为10，这个数组名称为`elementData`。

同时还会有一个变量`size`记录下一次插入时的索引值，同时也表示着当前ArrayList的元素的个数。

![image-20230508214643242](http://www.iocaop.com/images/2023-05/image-20230508214643242.png)

当元素个数超出底层数组长度时，会再次创建一个数组，长度是原来的<span style="background-color:pink;">1.5倍</span>，（在JDK 7及以下版本中是扩大为原来的2倍），并且会把原来数组的所有元素拷贝到新的数组中，`size`的值不变，然后再次插入。

![image-20230508214855095](http://www.iocaop.com/images/2023-05/image-20230508214855095.png)

查询数据：直接通过数组地址+索引获取。

看代码：

* 空参构造，底层创建一个长度为0的数组。关于`elementData`修饰符解释：<a href='https://www.cnblogs.com/xiaopan-cp9/p/15439454.html'>点击跳转</a>

![image-20230508214339019](http://www.iocaop.com/images/2023-05/image-20230508214339019.png)

* 向空ArrayList中添加一个元素时：

![image-20230508233248579](http://www.iocaop.com/images/2023-05/image-20230508233248579.png)

将元素、底层数组、size(当前集合元素个数)传递给如下add方法：

![image-20230508233435248](http://www.iocaop.com/images/2023-05/image-20230508233435248.png)

判断，如果当前集合元素个数等于底层数组长度，则进行扩容(调用grow方法)，否则进行数组赋值，size自增。

![image-20230508233626396](http://www.iocaop.com/images/2023-05/image-20230508233626396.png)

![image-20230508233819266](http://www.iocaop.com/images/2023-05/image-20230508233819266.png)

可以看到，将size+1后传递给了带参的扩容方法，使用了`Arrays`工具类的拷贝方法，将新数组赋值给了底层数组，新的数组复制了原来的所有值，且容量更大。

计算新数组长度的方法：

```java
    private int newCapacity(int minCapacity) {
        // minCapacity为size+1
        // overflow-conscious code
        // 取底层数组长度
        int oldCapacity = elementData.length;
        // 计算新数组长度，即旧容量+旧容量的一半(右移移位是除以2)，扩大1.5倍。
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        // 如果计算出来的新容量小于当前size+1，则再次进行判断，否则跳到return。 
        // 空集合第一次添加元素，minCapacity=0+1=1，newCapacity=0+0/2=0。满足条件，即新容量小于size+1.
        if (newCapacity - minCapacity <= 0) {
            // 底层数组是否未默认的空数组
            if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)
                // 如果是，则比较默认定义好的大小(10)和minCapacity，返回大的，调试时，空集合第一次添加一个元素情况，返回DEFAULT_CAPACITY
                return Math.max(DEFAULT_CAPACITY, minCapacity);
            // size+1小于0的话，说明溢出了int取值范围
            if (minCapacity < 0) // overflow
                throw new OutOfMemoryError();
            return minCapacity;
        }
        // 判断新容量是否在ArrayList允许的最大范围 int最大取值范围减8
        return (newCapacity - MAX_ARRAY_SIZE <= 0)
            ? newCapacity
            // 如果超过了，就调用如下方法重新计算
            : hugeCapacity(minCapacity);
    }
```

当新计算出来的容量超过int最大值时重新计算的方法：

```java
    private static int hugeCapacity(int minCapacity) {
        if (minCapacity < 0) // overflow
            throw new OutOfMemoryError();
        return (minCapacity > MAX_ARRAY_SIZE)
            ? Integer.MAX_VALUE
            : MAX_ARRAY_SIZE;
    }
```

为什么要多一层判断？

> 这是因为数组的索引从0开始，而不是1。如果MAX_ARRAY_SIZE等于Integer.MAX_VALUE，则分配一个长度为MAX_ARRAY_SIZE的数组将导致数组索引超出int类型的最大值。因此，MAX_ARRAY_SIZE需要比int类型的最大值小至少1，以确保安全使用。另外8的值可能与VM使用的一些空间大小有关。

### 15-LinkedList基本使用

```java
public class CollectionDemo08 {
    public static void main(String[] args) {
        LinkedList<String> list = new LinkedList<>();
        list.add("aaa");
        list.add("bbb");
        list.add("ccc");
        list.add("ddd");
        for (int i = 0; i < list.size(); i++) {
            System.out.println(list.get(i));
        }

        for (String s : list) {
            System.out.println(s);
        }

        Iterator<String> iterator = list.iterator();
        while (iterator.hasNext()){
            System.out.println(iterator.next());
        }
    }
}
```

### 16-LinkedList特有方法

![image-20230509125509409](http://www.iocaop.com/images/2023-05/image-20230509125509409.png)

```java
public class CollectionDemo09 {
    public static void main(String[] args) {
        LinkedList<String> list = new LinkedList<>();
        list.add("aaa");
        list.add("bbb");
        list.add("ccc");
        list.addFirst("111");
        list.addLast("222");
        System.out.println("list = " + list);
        System.out.println("list.getFirst() = " + list.getFirst());
        System.out.println("list.getLast() = " + list.getLast());
        list.removeFirst();
        System.out.println("list = " + list);
        list.removeLast();
        System.out.println("list = " + list);
    }
}
```

![image-20230509130531350](http://www.iocaop.com/images/2023-05/image-20230509130531350.png)

### 17-LinkedList源码浅读

`LinkedList`底层是双向链表：

![image-20230509125922893](http://www.iocaop.com/images/2023-05/image-20230509125922893.png)

按`ctrl+f12`可以查找类中成员。

可以找到`Node`是`LinkedList`中的一个内部类，就是节点。内部类`Node`对象，就是`LinkedList`中的节点对象。

```java
    private static class Node<E> {
        // 数据
        E item;
        // 前置指针
        Node<E> next;
        // 后置指针
        Node<E> prev;
		// 全参构造
        Node(Node<E> prev, E element, Node<E> next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
    }
```

`LinkedList`中维护了两个核心的成员变量：

![image-20230509131046276](http://www.iocaop.com/images/2023-05/image-20230509131046276.png)

创建好空的`LinkedList`后，链表为空，只有头结点和尾结点，此时`LinkedList`对象在堆内存中如下：

且都为null

![image-20230509164642578](http://www.iocaop.com/images/2023-05/image-20230509164642578.png)

添加元素时调用:

```java
    public boolean add(E e) {
        linkLast(e);
        return true;
    }
```

```java
    void linkLast(E e) {
        // 定义节点变量l 和last指向同一变量
        final Node<E> l = last;
        // 调用Node的带参构造，创建新节点,新节点的前置指针为l，
        // 因为l是添加这个节点之前的尾节点。后置指针为null
        final Node<E> newNode = new Node<>(l, e, null);
        // 将新创建出来的节点设置为尾结点
        last = newNode;
        // 判断创建新节点前，尾结点是否为null
        if (l == null)
            // 是则表示第一次添加元素，赋给头结点
            first = newNode;
        else
            // 否则将新节点作为尾节点并和添加新节点之前的尾结点连接
            l.next = newNode;
        size++;
        modCount++;
    }
```

```java
    private static class Node<E> {
        E item;
        Node<E> next;
        Node<E> prev;

        Node(Node<E> prev, E element, Node<E> next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
    }
```

