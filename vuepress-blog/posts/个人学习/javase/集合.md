---
title: java基础-集合
date: 2023-05-06
category:
  - JavaSE
---

## 9-1-Collection

### 01-集合与数组对比

* 数组的长度是不可变的，集合的长度是可变的。
* 数组可以存基本数据类型和引用数据类型。集合只能存引用数据类型，如果集合要存基本数据类型，需要存对应的<span style="background-color:pink;">包装类</span>。

### 02-集合体系结构

![image-20230506004215802](http://www.iocaop.com/images/2023-05/image-20230506004215802.png)

### 03-Collection常见成员方法

Collection概述和使用：

* 是单列集合的顶层接口，他表示一组对象，这些对象也称为`Collection`的元素
* JDK不提供此接口的任何实现。提供更具体的子接口(如`List`、`Set`)的实现。

创建Collection集合的对象

* 多态的方式
* 具体的实现类`ArrayList`

常用成员方法：

![image-20230506004713015](http://www.iocaop.com/images/2023-05/image-20230506004713015.png)

除了removeif方法，其他方法都比较常规。

```java
public class CollectionDemo01 {
    public static void main(String[] args) {
        Collection<String> list = new ArrayList<>();
        list.add("aaa");
        list.add("bbb");
        list.add("ccc");
        list.add("aaaa");
        list.removeIf(s->s.length()==3);
        System.out.println("list = " + list);
    }
}
```

![image-20230506010046853](http://www.iocaop.com/images/2023-05/image-20230506010046853.png)

参数是一个函数式接口，可以使用lamda表达式，会遍历整个集合，进行满足条件的就会进行删除。

解释：传入`Predicate`实现类，该方法会获取集合的迭代器，遍历集合元素，并调用实现类的`test`方法，逐个进行判断，如果实现类的`test`方法结果为`true`，则删除元素。

### 04-迭代器的基本使用

Collection接口中有获取迭代器对象的抽象方法：是由实现类提供具体实现。

![image-20230508101824877](http://www.iocaop.com/images/2023-05/image-20230508101824877.png)

作用：返回集合中的迭代器对象，该迭代器对象默认指向当前集合的0索引。

迭代器`Iterator`中的方法：

![image-20230508102050231](http://www.iocaop.com/images/2023-05/image-20230508102050231.png)

使用迭代器遍历集合：

```java
public class CollectionDemo03 {
    public static void main(String[] args) {
        Collection<String> list = new ArrayList<>();
        list.add("a");
        list.add("b");
        list.add("c");
        list.add("d");
        // 1 获取迭代器对象。迭代器对象一旦创建出来，默认指向0索引
        Iterator<String> iterator = list.iterator();


        // 2 利用迭代器中的方法来遍历集合
        // 迭代器当前指向位置是否有元素可以取出
        boolean b = iterator.hasNext();
        System.out.println(b);
        // next()方法做了两件事情，1取出当前位置元素 2将迭代器往后移动一个索引的位置
        System.out.println("iterator.next() = " + iterator.next());

        System.out.println("iterator.next() = " + iterator.next());
        System.out.println("iterator.next() = " + iterator.next());
        System.out.println("iterator.next() = " + iterator.next());
        System.out.println("iterator.next() = " + iterator.next());

    }
}
```

会报错：

![image-20230508102911014](http://www.iocaop.com/images/2023-05/image-20230508102911014.png)

> 为什么会报错？因为只有4个元素，却调用了5次next()方法，第五次调用时，迭代器指向的位置已经超出了集合索引范围。所以报错了

为了防止报错，在遍历时需要调用`hasNext()`方法，判断迭代器当前指向位置是否有元素可以取出。

```java
public class CollectionDemo03 {
    public static void main(String[] args) {
        Collection<String> list = new ArrayList<>();
        list.add("a");
        list.add("b");
        list.add("c");
        list.add("d");
        // 1 获取迭代器对象。迭代器对象一旦创建出来，默认指向0索引
        Iterator<String> iterator = list.iterator();
        
        // 2 利用迭代器中的方法来遍历集合
        // 迭代器当前指向位置是否有元素可以取出
        boolean b = iterator.hasNext();
        System.out.println(b);
        // next()方法做了两件事情，1取出当前位置元素 2将迭代器往后移动一个索引的位置
        while (iterator.hasNext()){
            System.out.println("iterator.next() = " + iterator.next());
        }
    }
}
```

### 05-迭代器原理

![image-20230508103621647](http://www.iocaop.com/images/2023-05/image-20230508103621647.png)

当迭代器指向最后一个元素时，`hasNext()`方法返回是false。原理个锤子。

### 06-迭代器的删除方法

先写个删除方法：删除集合中字符串为“b”的元素

```java
public class CollectionDemo04 {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("a");
        list.add("b");
        list.add("b");
        list.add("c");
        list.add("d");

        for (int i=0;i<list.size();i++){
            if ("b".equals(list.get(i))){
                list.remove(i);
            }
        }
        System.out.println("list = " + list);
    }
}
```

![image-20230508104225096](http://www.iocaop.com/images/2023-05/image-20230508104225096.png)

可以看到，有个元素明明是"b"却没有被删除，当我们换一下元素位置为：abcbd时(重复元素不连续)又能删除了：

![image-20230508104351060](http://www.iocaop.com/images/2023-05/image-20230508104351060.png)

为什么？

java中的List集合是动态的，当删除一个元素后，长度会自动减1，如图，删除索引1后，长度减1，索引又移动到2了，导致漏了一个元素没有被遍历到。

![image-20230508104652528](http://www.iocaop.com/images/2023-05/image-20230508104652528.png)

![image-20230508104712196](http://www.iocaop.com/images/2023-05/image-20230508104712196.png)

如何解决？

当成功删除后，索引往前移一个位置。

![image-20230508105037290](http://www.iocaop.com/images/2023-05/image-20230508105037290.png)

如果使用迭代器，就不会存在这个问题，迭代器的删除方法，是指向谁就删除谁：

```java
public class CollectionDemo05 {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("a");
        list.add("b");
        list.add("b");
        list.add("c");
        list.add("d");
        Iterator<String> iterator = list.iterator();
        while (iterator.hasNext()){
            String next = iterator.next();
            if ("b".equals(next)){
                // 指向谁就删除谁
                iterator.remove();
            }
        }
        System.out.println("list = " + list);
    }
}
```

gpt的解释：

![image-20230508110950667](http://www.iocaop.com/images/2023-05/image-20230508110950667.png)

迭代器能维护集合状态：

![image-20230508111037732](http://www.iocaop.com/images/2023-05/image-20230508111037732.png)

### 07-增强for

作用：简化<span style="background-color:pink;">数组</span>和<span style="background-color:pink;">Collection集合</span>的遍历

* jdk5以后出现的，内部是一个`Iterator`迭代器
* 实现`Iterable`接口的类才可以使用迭代器和增强for

单列集合顶层`Collection`实现了`Iterable`接口，而双列集合`Map`没有实现该接口。

![image-20230508205244919](http://www.iocaop.com/images/2023-05/image-20230508205244919.png)

![image-20230508205337288](http://www.iocaop.com/images/2023-05/image-20230508205337288.png)

可以得出结论：单列集合都可以使用增强for，而双列集合不行。

格式：

```java
for(元素数据类型 变量名:数组或Collection集合){
// 在此处使用变量即可，该变量就是元素
}
```

举例：

```java
public class CollectionDemo06 {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("a");
        list.add("b");
        list.add("b");
        list.add("c");
        list.add("d");
        // 1.数据类型一定是集合或数组中元素的类型
        // 2.s仅仅是一个变量名而已，在循环的过程中，依次表示集合或数组中的每一个元素
        // 3.list就是要遍历的集合或者数组
        for (String s : list) {
            System.out.println("s = " + s);
        }
    }
}
```

### 08-增强for注意点

```java
public class CollectionDemo07 {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("a");
        list.add("b");
        list.add("b");
        list.add("c");
        list.add("d");
        for (String s : list) {
            s="q";
            System.out.println("s = " + s);
        }
        System.out.println("list = " + list);
    }
}
```

运行结果：

![image-20230508210144493](http://www.iocaop.com/images/2023-05/image-20230508210144493.png)

<span style="background-color:pink;">在增强for中修改变量的值，不会影响集合中的元素</span>

![image-20230508210231708](http://www.iocaop.com/images/2023-05/image-20230508210231708.png)

目前为止学习了三种遍历方式：

* 如果需要操作索引，使用普通for
* 如果再遍历过程中需要删除元素，使用迭代器
* 仅仅只想遍历，使用增强for

## 9-2-List

### 10-List的特点

单列集合分为`List`和`Set`，都实现了`Collection`接口。List又分为`ArrayLis`t和`LinkedList`。

`List`集合特点：

* 有序：存储和取出的元素顺序一致
* 有索引：可以通过索引操作元素
* 可重复：存储的元素可以重复

### 11-List特有方法

| 方法名                          | 描述                                   |
| ------------------------------- | -------------------------------------- |
| void add(int index,E   element) | 在此集合中的指定位置插入指定的元素     |
| E remove(int   index)           | 删除指定索引处的元素，返回被删除的元素 |
| E set(int index,E   element)    | 修改指定索引处的元素，返回被修改的元素 |
| E get(int   index)              | 返回指定索引处的元素                   |

### 12-栈和队列

**栈**

因为只有一端开口，<span style="background-color:pink;">后进先出</span>。

![image-20230508211633942](http://www.iocaop.com/images/2023-05/image-20230508211633942.png)

**队列**

两端口，先进先出。

![image-20230508211851422](http://www.iocaop.com/images/2023-05/image-20230508211851422.png)

### 13-数组和链表

**数组**

![image-20230508212042398](http://www.iocaop.com/images/2023-05/image-20230508212042398.png)

查询快，增删慢。

为什么？

* 查询数据通过地址值和索引定位，查询任意数据耗时相同，查询速度快。
* 删除数据时，要将原始数据删除，同时后面每个元素前移，删除效率低。
* 添加数据时，添加位置后的每个数据右移，再添加元素，添加效率极低。

**链表**

![image-20230508212435696](http://www.iocaop.com/images/2023-05/image-20230508212435696.png)

图上节点中记录的是下一个元素的地址值，而不是值，图没画好。

上一个节点中记录下一个节点的地址值，形成链表。这是单链表。

对比数组，链表是一种增删快的模型。

添加删除时改变指针即可。

查询时，因为链表的<span style="background-color:pink;">元素所占内存是不连续的</span>，所以只能从head节点开始通过指针一个个往下找，查询慢。

链表又分单向链表、双向链表、循环链表等等。

![image-20230508213211792](http://www.iocaop.com/images/2023-05/image-20230508213211792.png)

### 14-ArrayList源码浅读

当我们调用<span style="background-color:pink;">空参构造创建</span>`ArrayList`时，会创建一个<span style="background-color:pink;">长度为0</span>的数组。再次向这个数组添加一个元素时，会<span style="background-color:pink;">重新创建一个长度为10的数组</span>，所以我们默认认为`ArrayList`底层数组默认长度为10，这个数组名称为`elementData`。

同时还会有一个变量`size`记录下一次插入时的索引值，同时也表示着当前ArrayList的元素的个数。

![image-20230508214643242](http://www.iocaop.com/images/2023-05/image-20230508214643242.png)

当元素个数超出底层数组长度时，会再次创建一个数组，长度是原来的<span style="background-color:pink;">1.5倍</span>，（在JDK 7及以下版本中是扩大为原来的2倍），并且会把原来数组的所有元素拷贝到新的数组中，`size`的值不变，然后再次插入。

![image-20230508214855095](http://www.iocaop.com/images/2023-05/image-20230508214855095.png)

查询数据：直接通过数组地址+索引获取。

看代码：

* 空参构造，底层创建一个长度为0的数组。关于`elementData`修饰符解释：<a href='https://www.cnblogs.com/xiaopan-cp9/p/15439454.html'>点击跳转</a>

![image-20230508214339019](http://www.iocaop.com/images/2023-05/image-20230508214339019.png)

* 向空ArrayList中添加一个元素时：

![image-20230508233248579](http://www.iocaop.com/images/2023-05/image-20230508233248579.png)

将元素、底层数组、size(当前集合元素个数)传递给如下add方法：

![image-20230508233435248](http://www.iocaop.com/images/2023-05/image-20230508233435248.png)

判断，如果当前集合元素个数等于底层数组长度，则进行扩容(调用grow方法)，否则进行数组赋值，size自增。

![image-20230508233626396](http://www.iocaop.com/images/2023-05/image-20230508233626396.png)

![image-20230508233819266](http://www.iocaop.com/images/2023-05/image-20230508233819266.png)

可以看到，将size+1后传递给了带参的扩容方法，使用了`Arrays`工具类的拷贝方法，将新数组赋值给了底层数组，新的数组复制了原来的所有值，且容量更大。

计算新数组长度的方法：

```java
    private int newCapacity(int minCapacity) {
        // minCapacity为size+1
        // overflow-conscious code
        // 取底层数组长度
        int oldCapacity = elementData.length;
        // 计算新数组长度，即旧容量+旧容量的一半(右移移位是除以2)，扩大1.5倍。
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        // 如果计算出来的新容量小于当前size+1，则再次进行判断，否则跳到return。 
        // 空集合第一次添加元素，minCapacity=0+1=1，newCapacity=0+0/2=0。满足条件，即新容量小于size+1.
        if (newCapacity - minCapacity <= 0) {
            // 底层数组是否未默认的空数组
            if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)
                // 如果是，则比较默认定义好的大小(10)和minCapacity，返回大的，调试时，空集合第一次添加一个元素情况，返回DEFAULT_CAPACITY
                return Math.max(DEFAULT_CAPACITY, minCapacity);
            // size+1小于0的话，说明溢出了int取值范围
            if (minCapacity < 0) // overflow
                throw new OutOfMemoryError();
            // 新容量小于原来的容量，且不是默认数组，则说明不需要扩容。
            return minCapacity;
        }
        // 判断新容量是否在ArrayList允许的最大范围 int最大取值范围减8
        return (newCapacity - MAX_ARRAY_SIZE <= 0)
            ? newCapacity
            // 如果超过了，就调用如下方法重新计算
            : hugeCapacity(minCapacity);
    }
```

当新计算出来的容量超过int最大值时重新计算的方法：

```java
    private static int hugeCapacity(int minCapacity) {
        if (minCapacity < 0) // overflow
            throw new OutOfMemoryError();
        return (minCapacity > MAX_ARRAY_SIZE)
            ? Integer.MAX_VALUE
            : MAX_ARRAY_SIZE;
    }
```

为什么要多一层判断？

> 这是因为数组的索引从0开始，而不是1。如果MAX_ARRAY_SIZE等于Integer.MAX_VALUE，则分配一个长度为MAX_ARRAY_SIZE的数组将导致数组索引超出int类型的最大值。因此，MAX_ARRAY_SIZE需要比int类型的最大值小至少1，以确保安全使用。另外8的值可能与VM使用的一些空间大小有关。

### 15-LinkedList基本使用

```java
public class CollectionDemo08 {
    public static void main(String[] args) {
        LinkedList<String> list = new LinkedList<>();
        list.add("aaa");
        list.add("bbb");
        list.add("ccc");
        list.add("ddd");
        for (int i = 0; i < list.size(); i++) {
            System.out.println(list.get(i));
        }

        for (String s : list) {
            System.out.println(s);
        }

        Iterator<String> iterator = list.iterator();
        while (iterator.hasNext()){
            System.out.println(iterator.next());
        }
    }
}
```

### 16-LinkedList特有方法

![image-20230509125509409](http://www.iocaop.com/images/2023-05/image-20230509125509409.png)

```java
public class CollectionDemo09 {
    public static void main(String[] args) {
        LinkedList<String> list = new LinkedList<>();
        list.add("aaa");
        list.add("bbb");
        list.add("ccc");
        list.addFirst("111");
        list.addLast("222");
        System.out.println("list = " + list);
        System.out.println("list.getFirst() = " + list.getFirst());
        System.out.println("list.getLast() = " + list.getLast());
        list.removeFirst();
        System.out.println("list = " + list);
        list.removeLast();
        System.out.println("list = " + list);
    }
}
```

![image-20230509130531350](http://www.iocaop.com/images/2023-05/image-20230509130531350.png)

### 17-LinkedList源码浅读

`LinkedList`底层是双向链表：

![image-20230509125922893](http://www.iocaop.com/images/2023-05/image-20230509125922893.png)

按`ctrl+f12`可以查找类中成员。

可以找到`Node`是`LinkedList`中的一个内部类，就是节点。内部类`Node`对象，就是`LinkedList`中的节点对象。

```java
    private static class Node<E> {
        // 数据
        E item;
        // 前置指针
        Node<E> next;
        // 后置指针
        Node<E> prev;
		// 全参构造
        Node(Node<E> prev, E element, Node<E> next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
    }
```

`LinkedList`中维护了两个核心的成员变量：

![image-20230509131046276](http://www.iocaop.com/images/2023-05/image-20230509131046276.png)

创建好空的`LinkedList`后，链表为空，只有头结点和尾结点，此时`LinkedList`对象在堆内存中如下：

且都为null

![image-20230509164642578](http://www.iocaop.com/images/2023-05/image-20230509164642578.png)

添加元素时调用:

```java
    public boolean add(E e) {
        linkLast(e);
        return true;
    }
```

```java
    void linkLast(E e) {
        // 定义节点变量l 和last指向同一变量
        final Node<E> l = last;
        // 调用Node的带参构造，创建新节点,新节点的前置指针为l，
        // 因为l是添加这个节点之前的尾节点。后置指针为null
        final Node<E> newNode = new Node<>(l, e, null);
        // 将新创建出来的节点设置为尾结点
        last = newNode;
        // 判断创建新节点前，尾结点是否为null
        if (l == null)
            // 是则表示第一次添加元素，赋给头结点
            first = newNode;
        else
            // 否则将新节点作为尾节点并和添加新节点之前的尾结点连接
            l.next = newNode;
        size++;
        modCount++;
    }
```

```java
    private static class Node<E> {
        E item;
        Node<E> next;
        Node<E> prev;

        Node(Node<E> prev, E element, Node<E> next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
    }
```

添加了一个元素后：

`LinkedList`中的两个变量`first`和`last`都被赋值为了这个`Node`对象，即新元素。图中节点都是在堆内存中，方便看，所以画在外面。

![3f683f120ec940e66653b1d26b019d4](http://www.iocaop.com/images/2023-05/3f683f120ec940e66653b1d26b019d4.jpg)

添加第二个元素时，`first`不变，第二个元素变为`last`，第一个元素`aaa`的next被赋值为了第二个元素，也就是第一个元素的next指针指向第二个元素。同时第二个元素`bbb`的prev又指向了`aaa`，在代码中可以看到，调用全参构造的时候把`l`传过去了。`l`的作用就是记录添加元素前的尾结点，用于创建下一个节点。图中节点都是在堆内存中，方便看，所以画在外面。

![97b9ae90da6b41890e85d9639033a1c](http://www.iocaop.com/images/2023-05/97b9ae90da6b41890e85d9639033a1c.jpg)

以此类推，不需要扩容，动态new出来的节点，设置好指针即可。

查找元素时源码：

```java
    public E get(int index) {
        checkElementIndex(index);
        return node(index).item;
    }
```

```java
    Node<E> node(int index) {
        // assert isElementIndex(index);
		// 将链表长度除以2，和需要查找的索引值进行比较，判断从头结点开始找还是从尾节点开始找
        if (index < (size >> 1)) {
            // 从头结点开始找，则让x为LinkedList对象中的first成员，因为他记录了头节点
            Node<E> x = first;
            // 按指定次数移动指针，每次赋值x为x的next指向的元素
            for (int i = 0; i < index; i++)
                x = x.next;
            return x;
        } else {
           // 从头结点开始找，则让x为LinkedList对象中的last成员，因为他记录了尾节点
            Node<E> x = last;
            for (int i = size - 1; i > index; i--)
                 // 按指定次数移动指针，每次赋值x为x的prev指向的元素
                x = x.prev;
            return x;
        }
    }
```

删除元素时：

```java
    public boolean remove(Object o) {
        // 分两种情况，被删除的元素是null，则循环查找为null的元素，调用unlink从链表中移除
        if (o == null) {
            for (Node<E> x = first; x != null; x = x.next) {
                if (x.item == null) {
                    unlink(x);
                    return true;
                }
            }
        } else {
            // 被删除的元素不为null,则循环查找元素，调用equals方法比较，结果为true的，调用unlink从链表中移除
            for (Node<E> x = first; x != null; x = x.next) {
                if (o.equals(x.item)) {
                    unlink(x);
                    return true;
                }
            }
        }
        return false;
    }
```

unlink方法：

```java
    E unlink(Node<E> x) {
        // assert x != null;
        // 记录被删除的元素的数据区
        final E element = x.item;
        // 记录被删除的元素的后置指针，在Java中就是后一个节点
        final Node<E> next = x.next;
        // 记录被删除的元素的前置指针，在Java中就是前一个节点
        final Node<E> prev = x.prev;
		// 如果被删除的元素的前置指针为null，说明被删除的元素是头结点
        if (prev == null) {
            // 设置整个链表的新的头节点为被删除的元素的下一个节点
            first = next;
        } else {
            // 被删除的元素不是链表的头结点，则设置被删除的元素的上一个节点的next节点为被删除的元素的下一个节点
            prev.next = next;
            // 置空被删除的元素的前置指针
            x.prev = null;
        }
		// 如果被删除的元素的后置指针为null，说明被删除的元素是尾结点
        if (next == null) {
            //设置整个链表的新的尾结点为被删除的元素的上一个节点
            last = prev;
        } else {
            // 被删除的元素不是链表的尾结点，则设置被删除的元素的下一个节点的前置指针为被删除的元素的上一个节点
            next.prev = prev;
            // 被删除的元素的后置指针为null
            x.next = null;
        }
		// 设置被删除元素的数据区为null
        x.item = null;
        size--;
        modCount++;
        return element;
    }
```

## 9-3-Set和泛型

### 01~02-概述和基本使用

单列集合`Collection`分为`List`和`Set`，`Set`又分为`HashSet`和`TreeSet`。`Set`集合最主要的特点就是不可重复，所有可以去除重复。

特点：

* 元素不可重复
* 元素存取顺序不一致
* 没有带索引的方法，不能通过普通for来遍历，也不能通过索引获取、删除元素

基本使用：

实现类有`TreeSet`和`HashSet`，没有索引：

![image-20230510001641556](http://www.iocaop.com/images/2023-05/image-20230510001641556.png)

```java
public class CollectionDemo10 {
    public static void main(String[] args) {
        Set<String> set = new TreeSet<>();
        set.add("aaa");
        set.add("bbb");
        set.add("ccc");
        set.add("ddd");
        // 没有索引，所以通过迭代器来遍历
        Iterator<String> iterator = set.iterator();
        while (iterator.hasNext()){
            System.out.println("iterator.next() = " + iterator.next());
        }
        // 增强for原理也是迭代器,Collection实现了Iterable，所以可以使用增强for来遍历
        for (String s : set) {
            System.out.println("s = " + s);
        }
    }
}
```

![image-20230510001842143](http://www.iocaop.com/images/2023-05/image-20230510001842143.png)

为了验证元素不重复和存取顺序不一致。稍微调整：

![image-20230510002006362](http://www.iocaop.com/images/2023-05/image-20230510002006362.png)

