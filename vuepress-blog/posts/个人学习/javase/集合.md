---
title: java基础-集合
date: 2023-05-06
category:
  - JavaSE
---

## 9-1-Collection

### 01-集合与数组对比

* 数组的长度是不可变的，集合的长度是可变的。
* 数组可以存基本数据类型和引用数据类型。集合只能存引用数据类型，如果集合要存基本数据类型，需要存对应的<span style="background-color:pink;">包装类</span>。

### 02-集合体系结构

![image-20230506004215802](http://www.iocaop.com/images/2023-05/image-20230506004215802.png)

### 03-Collection常见成员方法

Collection概述和使用：

* 是单列集合的顶层接口，他表示一组对象，这些对象也称为`Collection`的元素
* JDK不提供此接口的任何实现。提供更具体的子接口(如`List`、`Set`)的实现。

创建Collection集合的对象

* 多态的方式
* 具体的实现类`ArrayList`

常用成员方法：

![image-20230506004713015](http://www.iocaop.com/images/2023-05/image-20230506004713015.png)

除了removeif方法，其他方法都比较常规。

```java
public class CollectionDemo01 {
    public static void main(String[] args) {
        Collection<String> list = new ArrayList<>();
        list.add("aaa");
        list.add("bbb");
        list.add("ccc");
        list.add("aaaa");
        list.removeIf(s->s.length()==3);
        System.out.println("list = " + list);
    }
}
```

![image-20230506010046853](http://www.iocaop.com/images/2023-05/image-20230506010046853.png)

参数是一个函数式接口，可以使用lamda表达式，会遍历整个集合，进行满足条件的就会进行删除。

解释：传入`Predicate`实现类，该方法会获取集合的迭代器，遍历集合元素，并调用实现类的`test`方法，逐个进行判断，如果实现类的`test`方法结果为`true`，则删除元素。

### 04-迭代器的基本使用

Collection接口中有获取迭代器对象的抽象方法：是由实现类提供具体实现。

![image-20230508101824877](http://www.iocaop.com/images/2023-05/image-20230508101824877.png)

作用：返回集合中的迭代器对象，该迭代器对象默认指向当前集合的0索引。

迭代器`Iterator`中的方法：

![image-20230508102050231](http://www.iocaop.com/images/2023-05/image-20230508102050231.png)

使用迭代器遍历集合：

```java
public class CollectionDemo03 {
    public static void main(String[] args) {
        Collection<String> list = new ArrayList<>();
        list.add("a");
        list.add("b");
        list.add("c");
        list.add("d");
        // 1 获取迭代器对象。迭代器对象一旦创建出来，默认指向0索引
        Iterator<String> iterator = list.iterator();


        // 2 利用迭代器中的方法来遍历集合
        // 迭代器当前指向位置是否有元素可以取出
        boolean b = iterator.hasNext();
        System.out.println(b);
        // next()方法做了两件事情，1取出当前位置元素 2将迭代器往后移动一个索引的位置
        System.out.println("iterator.next() = " + iterator.next());

        System.out.println("iterator.next() = " + iterator.next());
        System.out.println("iterator.next() = " + iterator.next());
        System.out.println("iterator.next() = " + iterator.next());
        System.out.println("iterator.next() = " + iterator.next());

    }
}
```

会报错：

![image-20230508102911014](http://www.iocaop.com/images/2023-05/image-20230508102911014.png)

> 为什么会报错？因为只有4个元素，却调用了5次next()方法，第五次调用时，迭代器指向的位置已经超出了集合索引范围。所以报错了

为了防止报错，在遍历时需要调用`hasNext()`方法，判断迭代器当前指向位置是否有元素可以取出。

```java
public class CollectionDemo03 {
    public static void main(String[] args) {
        Collection<String> list = new ArrayList<>();
        list.add("a");
        list.add("b");
        list.add("c");
        list.add("d");
        // 1 获取迭代器对象。迭代器对象一旦创建出来，默认指向0索引
        Iterator<String> iterator = list.iterator();
        
        // 2 利用迭代器中的方法来遍历集合
        // 迭代器当前指向位置是否有元素可以取出
        boolean b = iterator.hasNext();
        System.out.println(b);
        // next()方法做了两件事情，1取出当前位置元素 2将迭代器往后移动一个索引的位置
        while (iterator.hasNext()){
            System.out.println("iterator.next() = " + iterator.next());
        }
    }
}
```

