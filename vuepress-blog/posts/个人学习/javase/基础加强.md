---
title: java基础-基础加强
date: 2023-07-07
category:
  - JavaSE
---

## 13-1-类加载器和反射

### 01-类加载器-初步了解

将编译后的`class`文件加载到jvm虚拟中

![image-20230707003742191](http://www.iocaop.com/images/2023-07/202307070037224.png)

### 02-类加载器-加载过程

类在什么时候加载到内存中呢？

类加载的时机：

* 创建类的实例
* 调用类的类方法
* 访问类或者接口的类变量(静态变量)，或者为该变量赋值
* 使用反射方式强制创建某个类或接口对应的`java.lang.Class`对象
* 初始化某个类的子类(创建子类对象，需要父类的字节码文件也加载到内存中)
* 直接使用java.exe命令来运行某个主类

总结一句话：<span style="background-color:pink;">用到就加载，不用不加载</span>

### 03-类的加载过程-加载

![image-20230707004142901](http://www.iocaop.com/images/2023-07/202307070041931.png)

加载：

* 通过一个类的全限定名来获取定义此类的二进制字节流(<span style="background-color:pink;">包名+类名，获取这个类，准备用流进行传输</span>)
* 将这个字节流所代表的静态存储结构转化为运行时数据结构(<span style="background-color:pink;">把这个类加载到内存中</span>)
* 在内存中生产一个代表这个类的`java.lang.Class`对象，任何类被使用时，系统都会为之创建一个`java.lang.Class`对象(<span style="background-color:pink;">加载完毕，创建class对象</span>)

### 04-类的加载过程-链接

链接分为三步：验证-准备-解析

**验证**：确保`Class`文件字节流中包含的信息符合当前虚拟机的要求，不会损害虚拟机安全。(<span style="background-color:pink;">验证文件是否符合虚拟机规范，是否安全</span>)

**准备**：负责为类的类变量(静态变量)分配内存，设置默认初始化值。(<span style="background-color:pink;">在刚刚创建的class对象中，初始化静态变量</span>)

**解析**：将类的二进制数据流中的符号引用替换为直接引用。(如果本类用到了其他的类，此时就需要找到对应的类)

假设加载的是`Student`类：

![image-20230707005159077](http://www.iocaop.com/images/2023-07/202307070051099.png)

起初还不知道`String`这个类在哪里，先用符号表示：

![image-20230707005252017](http://www.iocaop.com/images/2023-07/202307070052050.png)

假设`String`如下：

![image-20230707005335462](http://www.iocaop.com/images/2023-07/202307070053480.png)

在`Student`类的加载过程的解析这一步，就会将符号替换成`String`的地址：

![image-20230707005419829](http://www.iocaop.com/images/2023-07/202307070054861.png)

### 05-类的加载过程-初始化

初始化：根据程序员通过程序制定的主管计划去初始化类变量和其他资源(<span style="background-color:pink;">静态变量赋值(覆盖原来的默认值)以及初始化其他资源)</span>

小结：

* 当类使用到的时候，才会加载到内存
* 类的加载过程：
  * 加载
  * 验证
  * 准备
  * 解析
  * 初始化

### 06-类加载器-分类

* 启动类加载器(Bootstrap ClassLoader):虚拟机内置的加载器(C++实现的)，虚拟机启动时自动启动。

* 平台类加载器(Platform ClassLoader)：负责加载JDK中一些特殊的模块。
* 系统类加载器(SysTem ClassLoader)：加载用户类路径上指定的类库。

> 这套课程讲得和网上资料有些不同：<a href='https://juejin.cn/post/7053314646077341710'>点击跳转</a>，其他资料一般说的是：启动类加载器、扩展类加载器、应用程序类加载器、用户自定义类加载器。
>
> 查资料后得知：Java9将扩展类加载器改为了平台类加载器

### 07-类加载器-双亲委派模型

<span style="background-color:pink;">除了启动类加载器之外，其他的加载器都应该有自己的父类加载器</span>。

> 这里说的父类加载器，并不是`extends`，而是逻辑上的继承

当用户类加载器收到类的加载请求，不会自己去加载，而是<span style="background-color:pink;">一层层往上委托</span>。

![image-20230707111835547](http://www.iocaop.com/images/2023-07/image-20230707111835547.png)

这些加载器，都<span style="background-color:pink;">有各自的加载范围，当父类加载器所有的加载范围，无法完成类的加载时，就会一层一层往下返回</span>，由子加载器尝试进行加载。

![image-20230707112122976](http://www.iocaop.com/images/2023-07/image-20230707112122976.png)

在`ClassLoader`这个类中有静态方法`getSystemClassLoader`可以获取到系统类加载器，再通过`getParent`可以获得他的父类加载器(扩展类加载器)

```java
public class ClassLoaderDemo01 {

    public static void main(String[] args) {

        // 获取系统类加载器
        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
        System.out.println("systemClassLoader = " + systemClassLoader);

        // 获取系统类加载器的父类加载器 --> 扩展类加载器
        ClassLoader extClassLoader = systemClassLoader.getParent();
        System.out.println("extClassLoader = " + extClassLoader);

        // 获取扩展类加载器的父类加载器 --> 根加载器(C/C++)
        ClassLoader bootClassLoader = extClassLoader.getParent();
        System.out.println("bootClassLoader = " + bootClassLoader);

        // 测试当前类由哪个类加载器进行加载 --> 系统类加载器
        ClassLoader classLoader = ClassLoaderDemo01.class.getClassLoader();
        System.out.println("当前类是谁加载的："+classLoader);

        // 测试JDK内置的类是谁加载的 --> 根加载器
        ClassLoader classLoader1 = Object.class.getClassLoader();
        System.out.println("Object是谁加载的："+classLoader1);

        // 如何获得系统类加载器可以加载的路径
        System.out.println("系统类加载器可以加载的路径"+System.getProperty("java.class.path"));
        
    }
}
```

![image-20230709191319442](http://www.iocaop.com/images/2023-07/202307091913479.png)

### 08-类加载器-常用方法

![image-20230709191958794](http://www.iocaop.com/images/2023-07/202307091919830.png)

```java
public class ClassLoaderDemo02 {

    public static void main(String[] args) {
        // 获取系统类加载器
        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
        InputStream resourceAsStream = systemClassLoader.getResourceAsStream("prop.properties");
        Properties properties = new Properties();
        try {
            properties.load(resourceAsStream);
            System.out.println(properties);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}

```

![image-20230709200320920](http://www.iocaop.com/images/2023-07/202307092003945.png)

![image-20230709200437363](http://www.iocaop.com/images/2023-07/202307092006613.png)

### 09-反射-概述

运行状态中：

对任意一个类，都能够知道这个类的所有属性和方法。

对于一个对象，都能够调用它的任意属性和方法。

可以先获取配置文件中的信息，动态获取信息并创建对象和调用方法。(先写好类，在配置文件指明要使用的类和调用的方法，动态去调用)

> 利用反射调用它类中的属性和方法时，无视修饰符。

### 10-反射-获取class对象

在不同的阶段，可以使用不同的方法来获取class对象，有以下三种：

![image-20230709201745858](http://www.iocaop.com/images/2023-07/202307092017897.png)

```java
public class Student {
    private String name;

    private Integer age;

    private void study(){
        System.out.println("学生正在学习");
    }

    public Student(String name) {
        this.name = name;
        System.out.println("name = " + name);
        System.out.println("只有name参数的构造");
    }

    public Student(Integer age) {
        this.age = age;

        System.out.println("age = " + age);
        System.out.println("只有age参数的构造");
    }

    public Student(String name, Integer age) {
        this.name = name;
        this.age = age;
        System.out.println("name = " + name);
        System.out.println("age = " + age);
        System.out.println("全参构造");
    }

    public Student() {
        System.out.println("无参构造");
    }


    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}

```



```java
public class RefDemo01 {

    public static void main(String[] args) throws ClassNotFoundException {

        // 方法1 使用静态方法获取class对象，需要传入的参数为全类名  源码阶段
        Class<?> class1 = Class.forName("com.lzc.ref.ref1.Student");
        System.out.println("class1 = " + class1);

        // 方法2：通过class属性来获取  内存阶段
        Class<Student> class2 = Student.class;
        System.out.println("class2 = " + class2);

        // 方法3：对象阶段
        Student student = new Student();
        Class<? extends Student> class3 = student.getClass();
        System.out.println("class3 = " + class3);

        // 需要注意，一个类只有一个class对象，是唯一的 不管用什么方式获取的，都是同一个

        System.out.println("class1==class2 = " + (class1 == class2));

        System.out.println("(class2==class3) = " + (class2 == class3));
        
    }
}
```

![image-20230709202404576](http://www.iocaop.com/images/2023-07/202307092024610.png)

### 11-反射-获取Constructor对象

当一个类的字节码加载到内存中以后，内存中记录了以下信息：

![image-20230709202558669](http://www.iocaop.com/images/2023-07/202307092025705.png)

通过反射就可以获取这些信息。在Java中，万物皆对象。成员变量就是`Field`对象，构造方法就是`Constructor`对象，成员方法就是`Method`对象

![image-20230709202721319](http://www.iocaop.com/images/2023-07/202307092027348.png)
