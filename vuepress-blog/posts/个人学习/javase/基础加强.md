---
title: java基础-基础加强
date: 2023-07-07
category:
  - JavaSE
---

## 13-1-类加载器和反射

### 01-类加载器-初步了解

将编译后的`class`文件加载到jvm虚拟中

![image-20230707003742191](http://www.iocaop.com/images/2023-07/202307070037224.png)

### 02-类加载器-加载过程

类在什么时候加载到内存中呢？

类加载的时机：

* 创建类的实例
* 调用类的类方法
* 访问类或者接口的类变量(静态变量)，或者为该变量赋值
* 使用反射方式强制创建某个类或接口对应的`java.lang.Class`对象
* 初始化某个类的子类(创建子类对象，需要父类的字节码文件也加载到内存中)
* 直接使用java.exe命令来运行某个主类

总结一句话：<span style="background-color:pink;">用到就加载，不用不加载</span>

### 03-类的加载过程-加载

![image-20230707004142901](http://www.iocaop.com/images/2023-07/202307070041931.png)

加载：

* 通过一个类的全限定名来获取定义此类的二进制字节流(<span style="background-color:pink;">包名+类名，获取这个类，准备用流进行传输</span>)
* 将这个字节流所代表的静态存储结构转化为运行时数据结构(<span style="background-color:pink;">把这个类加载到内存中</span>)
* 在内存中生产一个代表这个类的`java.lang.Class`对象，任何类被使用时，系统都会为之创建一个`java.lang.Class`对象(<span style="background-color:pink;">加载完毕，创建class对象</span>)

### 04-类的加载过程-链接

链接分为三步：验证-准备-解析

**验证**：确保`Class`文件字节流中包含的信息符合当前虚拟机的要求，不会损害虚拟机安全。(<span style="background-color:pink;">验证文件是否符合虚拟机规范，是否安全</span>)

**准备**：负责为类的类变量(静态变量)分配内存，设置默认初始化值。(<span style="background-color:pink;">在刚刚创建的class对象中，初始化静态变量</span>)

**解析**：将类的二进制数据流中的符号引用替换为直接引用。(如果本类用到了其他的类，此时就需要找到对应的类)

假设加载的是`Student`类：

![image-20230707005159077](http://www.iocaop.com/images/2023-07/202307070051099.png)

起初还不知道`String`这个类在哪里，先用符号表示：

![image-20230707005252017](http://www.iocaop.com/images/2023-07/202307070052050.png)

假设`String`如下：

![image-20230707005335462](http://www.iocaop.com/images/2023-07/202307070053480.png)

在`Student`类的加载过程的解析这一步，就会将符号替换成`String`的地址：

![image-20230707005419829](http://www.iocaop.com/images/2023-07/202307070054861.png)

### 05-类的加载过程-初始化

初始化：根据程序员通过程序制定的主管计划去初始化类变量和其他资源(<span style="background-color:pink;">静态变量赋值(覆盖原来的默认值)以及初始化其他资源)</span>

小结：

* 当类使用到的时候，才会加载到内存
* 类的加载过程：
  * 加载
  * 验证
  * 准备
  * 解析
  * 初始化

### 06-类加载器-分类

* 启动类加载器(Bootstrap ClassLoader):虚拟机内置的加载器(C++实现的)，虚拟机启动时自动启动。

* 平台类加载器(Platform ClassLoader)：负责加载JDK中一些特殊的模块。
* 系统类加载器(SysTem ClassLoader)：加载用户类路径上指定的类库。

> 这套课程讲得和网上资料有些不同：<a href='https://juejin.cn/post/7053314646077341710'>点击跳转</a>，其他资料一般说的是：启动类加载器、扩展类加载器、应用程序类加载器、用户自定义类加载器。

### 07-类加载器-双亲委派模型

<span style="background-color:pink;">除了启动类加载器之外，其他的加载器都应该有自己的父类加载器</span>。

> 这里说的父类加载器，并不是`extends`，而是逻辑上的继承

当用户类加载器收到类的加载请求，不会自己去加载，而是<span style="background-color:pink;">一层层往上委托</span>。

![image-20230707111835547](http://www.iocaop.com/images/2023-07/image-20230707111835547.png)

这些加载器，都<span style="background-color:pink;">有各自的加载范围，当父类加载器所有的加载范围，无法完成类的加载时，就会一层一层往下返回</span>，由子加载器尝试进行加载。

![image-20230707112122976](http://www.iocaop.com/images/2023-07/image-20230707112122976.png)

在`ClassLoader`这个类中有静态方法`getSystemClassLoader`可以获取到系统类加载器，再通过`getParent`可以获得他的父类加载器(扩展类加载器)